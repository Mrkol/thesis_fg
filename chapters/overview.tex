\section{Обзор существующих работ}
\subsection{Имплементации}

\subsubsection*{Frostbite}
EA выступление\cite{FrostbiteGdcTalk}

\subsubsection*{Halcyon}
EA выступление\cite{HalcyonRapidInnovationTalk}
идеален во всём, но пока только R\&D

\subsubsection*{Unity}
документация\cite{UnityRenderGraph}
закрытая, но вроде хорошая

\subsubsection*{Unreal Engine}
документация\cite{UERenderDependencyGraph}

\subsubsection*{Anvil}
Ubisoft выступление\cite{DX12CaseStudies}
есть алиасинг, есть автобарьеры (сплит), умеет в несколько очередей сабмита

\subsubsection*{Granite}
блог\cite{GraniteBlogPost}

\subsubsection*{Прочие}
Неинтересные:
https://github.com/azhirnov/FrameGraph -- нет алиасинга, очень много ООП, намертво привязан к вулкану, вершины не реордерятся, содержимое вершин -- фиксированные таски, а не произвольный код, нет хистори ресурсов, есть барьеры, ВРОДЕ БЫ нет алиасинга
https://github.com/skaarj1989/FrameGraph -- нет алиасинга, нет хистори ресурсов, нет барьеров, кросс-АПИ, прикольный интерфейс на C++, видимо заброшен
https://github.com/Raikiri/LegitEngine -- ОТЕЧЕСТВЕННОЕ!!!

\subsection{Аллокация ресурсов}
Задача поиска расписания аллокации ресурсов в графе кадра в своей простейшей формулировке является классической задачей динамической аллокации памяти (dynamic storage allocation, DSA\cite[стр. 226]{10.5555/574848}). Стоит отметить, что разные авторы понимают эту задачу по-разному: с одной стороны название подразумевает онлайн-алгоритм, отвечающий на удалённые во времени запросы аллокации и деаллокации, а с другой стороны формулировка подразумевает оффлайн-алгоритм, которому заранее известна вся история жизней ресурсов. Оба понимания хорошо изучены и применены к различным приложениям. В рамках данной работы для ясности мы будем называть онлайн интерпретацию этой задачи изначальным названием (DSA), а оффлайн интерпретацию задачей о \textit{статической аллокации памяти} (static storage allocation, SSA).

В литературе существует более общая задача об аллокации памяти (storage allocation problem, SAP), расширяющую дополнительными ограничениями задачу SSA. Недавним прорывом в эффективном решении этой задачи было нахождение полиномиального алгоритма с ошибкой относительно оптимума менее чем в 2 раза\cite{https://doi.org/10.48550/arxiv.1911.10871}.

Похожая задача, как бы это не было удивительно, возникает в области оперирования морских контейнерных терминалов. С ростом сложности и нагруженности глобальных транспортных цепочек, прикладные задачи оперирования верфей стали слишком сложны для интуитивного их решения. В связи с этим за последние несколько десятилетий было сформулировано и в той или иной степени решено множество вариаций \textit{задачи об аллокации верфи}, покрывающих широкий спектр прикладных задач, возникающих в портах по всему миру. Задача динамической аллокации памяти с некоторыми допущениями эквивалентна одной из формулировок этой задачи, а именно вариации $cont|dyn|fix|max(res)$ по классификации обзорной статьи Бирвирта и Мизла\cite{BIERWIRTH2010615}. Решая эту задачу, авторы статей фокусируются на статическом аспекте аллокации, так как расписание прибытия кораблей известно заранее. Именно из-за этого задача об аллокации верфи представляет интерес в рамках данной работы.

Одним из первых интересующую нас формулировку задачи об аллокации верфи рассмотрел в своей статье Эндрю Лим\cite{LIM1998105}. Ресурсы, имеющие фиксированные и известные размер и времена аллокации и деаллокации, могут быть рассмотрены как корабли с соответствующей длинной, временем прибытия и временем отплытия, а тип используемой видеопамяти как секция верфи. Задача нахождения минимальной длинны всех секций верфи и точек прибытия всех кораблей аналогична нахождению минимального необходимого объёма памяти и локаций всех ресурсов в этой памяти. Однако, в отличии от рассматриваемой Лимом задачи, ресурсы не накладывают требований на отступ между друг другом и началом или концом верфи, зато требуют определённого выравнивания их начала в памяти. 

Однако в данной работе рассматривается не простейшая формулировка задачи аллокации ресурсов во фреймграфе, а более общая задача, которую мы будем называть \textit{статической аллокацией циклических ресурсов} (cyclic static storage allocation, CSSA). В современных алгоритмах компьютерной графики широко распространено переиспользование информации с прошлых кадров (СФОРМУЛИРОВАТЬ ЛУЧШЕ, ССЫЛКИ).

