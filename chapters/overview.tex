\section{Обзор существующих работ}
\subsection{Имплементации}
\subsubsection*{Frostbite}
Первыми идею организации архитектуры рендеринга в приложениях реального времени через вычислительные графы предложили разработчики движка Frostbite в 2017 году\cite{FrostbiteGdcTalk}. \textit{Кадровый граф} позволил им сделать ядро модуля рендеринга расширяемым, упростил работу с асинхронным вычислениями общего назначения на GPU, автоматизировал работу со специализированными видами оперативной видеопамяти на игровых консолях, а также сэкономил "тонны" обычной видеопамяти. В силу проприетарности движка не известно, насколько широкий класс сценариев использования ресурсов она поддерживает. В качестве схемы аллокации ресурсов же был взят обычный онлайн-аллокатор, располагающий в заранее выделенном крупном участке памяти ресурсы по мере необходимости. Автоматическая расстановка барьеров на 2017 год не поддерживалась.

\subsubsection*{Halcyon}
Далее, в 2019 году, компания EA представила\cite{HalcyonRapidInnovationTalk} новый экспериментальный движок Halcyon, обобщающий идею кадрового графа до \textit{графа рендеринга}.

\subsubsection*{Unity}
документация\cite{UnityRenderGraph}
закрытая, но вроде хорошая

\subsubsection*{Unreal Engine}
документация\cite{UERenderDependencyGraph}

\subsubsection*{Anvil}
Ubisoft выступление\cite{DX12CaseStudies}
есть алиасинг, есть автобарьеры (сплит), умеет в несколько очередей сабмита

\subsubsection*{Granite}
блог\cite{GraniteBlogPost}

\subsubsection*{Прочие}
Неинтересные:
https://github.com/azhirnov/FrameGraph -- нет алиасинга, очень много ООП, намертво привязан к вулкану, вершины не реордерятся, содержимое вершин -- фиксированные таски, а не произвольный код, нет хистори ресурсов, есть барьеры, ВРОДЕ БЫ нет алиасинга
https://github.com/skaarj1989/FrameGraph -- нет алиасинга, нет хистори ресурсов, нет барьеров, кросс-АПИ, прикольный интерфейс на C++, видимо заброшен
https://github.com/Raikiri/LegitEngine -- ОТЕЧЕСТВЕННОЕ!!!

\subsection{Аллокация ресурсов}
Задача поиска расписания аллокации ресурсов в графе кадра в своей простейшей формулировке является классической сильно NP-сложной\cite{DSAnpcomplete} задачей \textit{динамической аллокации памяти} (dynamic storage allocation, DSA\cite[с. 226]{10.5555/574848}). У этой задачи существует две интерпретации, он-лайн и офф-лайн. Первая подразумевает обработку разнесённых во времени запросов на аллокацию и деаллокацию ресурсов, иначе говоря, решения об адресах ресурсов в памяти необходимо принимать в порядке времён появления ресурсов. Этот частный случай часто встречается в операционных системах и рантаймах языков программирования. Вторая же интерпретация подразумевает наличие заранее известных времён жизни всех ресурсов. В рамках данной работы нас интересует именно офф-лайн интерпретация, поэтому, в отсутствие уточнения, под задачей о динамической аллокации памяти мы будем подразумевать именно её.

Одним из первых полиномиальных алгоритмов предложенных для решения задачи DSA является алгоритм First-Fit\cite{chrobak_packing_1988}, работающий, как было вскоре доказано Кирстедом, с константной ошибкой не более чем в 80 раз\cite{kierstead_linearity_1988}. Тремя годами позже Кирстед представил алгоритм с ошибкой не более чем в 6 раз\cite{kierstead_polynomial_1991}. Эти и другие ранние работы объединяет общий подход сведения DSA к частному случаю с единичным размером всех ресурсов, эквивалентному покраске интервального графа, и последующим применением он-лайн алгоритма покраски. Через несколько лет Йордан Гергов, отказавшись от сведения к интервальным графам, смог понизить верхнюю оценку минимальной возможной ошибки до 5\cite{gergov_approximation_1996}, а в последствии и до 3\cite{gergov_algorithms_1999}. Наконец, наилучший на данный момент результат был получен исследователями из AT\&T Labs совместно с коллегой из Ecole Polytechnique\cite{buchsbaum_opt_2003}: полиномиальный алгоритм, для любого заранее выбранного $\varepsilon$ дающий $(2+\varepsilon)$-приблизительное решение DSA. Более того, для некоторых частных случаев авторы предоставляют приближённую схему полиномиального времени (то есть $(1+\varepsilon)$-приближение). Из них в рамках графа кадра особо интересна схема для случая ресурсов, размер которых ограничен сверху константой $h_{max}$. Однако практичность представленных алгоритмов в рамках приложений реального времени является открытым вопросом в силу их высокой сложности (TODO: оценить асимптотику по мастер-теореме).

Похожая задача, как бы это не было удивительно, возникает в области оперирования морских контейнерных терминалов. С ростом сложности и нагруженности глобальных транспортных цепочек, прикладные задачи оперирования верфей стали слишком сложны для интуитивного их решения. В связи с этим за последние несколько десятилетий было сформулировано и в той или иной степени решено множество вариаций \textit{задачи об аллокации верфи}, покрывающих широкий спектр прикладных задач. Так как расписания прибытия кораблей обычно известно портам заранее, офф-лайн задача динамической аллокации памяти является частным случаем одной из формулировок этой задачи, а именно вариации $cont|dyn|fix|max(res)$ по классификации обзорной статьи Бирвирта и Мизла\cite{BIERWIRTH2010615}. Именно из-за этого задача об аллокации верфи представляет интерес в рамках данной работы.

Одним из первых интересующую нас формулировку задачи об аллокации верфи рассмотрел в своей статье Эндрю Лим\cite{LIM1998105}. Ресурсы, имеющие фиксированные и известные размер и времена аллокации и деаллокации, могут быть рассмотрены как корабли с соответствующей длинной, временем прибытия и временем отплытия, а тип используемой видеопамяти как секция верфи. Задача нахождения минимальной длинны всех секций верфи и точек прибытия всех кораблей аналогична нахождению минимального необходимого объёма памяти и локаций всех ресурсов в этой памяти. Однако, в отличии от рассматриваемой Лимом задачи, ресурсы не накладывают требований на отступ между друг другом и началом или концом верфи, зато требуют определённого выравнивания их начала в памяти. Впрочем, последние условие достаточно легко сводится к первому.

Однако в данной работе рассматривается более общая формулировка задачи об аллокации ресурсов, насколько известно авторам, не рассматривавшаяся ранее в литературе.

