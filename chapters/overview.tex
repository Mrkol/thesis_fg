\section{Обзор существующих работ}
\subsection{Имплементации}

\subsubsection*{Frostbite}
EA выступление\cite{FrostbiteGdcTalk}

\subsubsection*{Halcyon}
EA выступление\cite{HalcyonRapidInnovationTalk}
идеален во всём, но пока только R\&D

\subsubsection*{Unity}
документация\cite{UnityRenderGraph}
закрытая, но вроде хорошая

\subsubsection*{Unreal Engine}
документация\cite{UERenderDependencyGraph}

\subsubsection*{Anvil}
Ubisoft выступление\cite{DX12CaseStudies}
есть алиасинг, есть автобарьеры (сплит), умеет в несколько очередей сабмита

\subsubsection*{Granite}
блог\cite{GraniteBlogPost}

\subsubsection*{Прочие}
Неинтересные:
https://github.com/azhirnov/FrameGraph -- нет алиасинга, очень много ООП, намертво привязан к вулкану, вершины не реордерятся, содержимое вершин -- фиксированные таски, а не произвольный код, нет хистори ресурсов, есть барьеры, ВРОДЕ БЫ нет алиасинга
https://github.com/skaarj1989/FrameGraph -- нет алиасинга, нет хистори ресурсов, нет барьеров, кросс-АПИ, прикольный интерфейс на C++, видимо заброшен
https://github.com/Raikiri/LegitEngine -- ОТЕЧЕСТВЕННОЕ!!!

\subsection{Аллокация ресурсов}
Задача поиска расписания аллокации ресурсов в графе кадра в своей простейшей формулировке является классической задачей динамической аллокации памяти (dynamic storage allocation, DSA\cite[стр. 226]{10.5555/574848}). Однако с названием и формулировкой этой задачи вышел казус: название задачи подразумевает онлайн-алгоритм, отвечающий на запросы аллокации по мере их поступления, а формулировка подразумевает оффлайн-алгоритм, знающий расписание использования ресурсов заранее. К сожалению большая часть работ посвящённых этой задаче фокусируется именно на динамическом аспекте, в то время как в данной работе интересен именно статический аспект. Некоторые авторы рассматривают обобщённую задачу об аллокации памяти (storage allocation problem, SAP), акцентирующую оффлайн аспект проблемы. Недавним прорывом в эффективном решении этой задачи было нахождение полиномиального алгоритма с ошибкой относительно оптимума менее чем в 2 раза\cite{https://doi.org/10.48550/arxiv.1911.10871}.

Похожая задача, как бы это не было удивительно, возникает в области оперирования морских контейнерных терминалов. С ростом сложности и нагруженности глобальных транспортных цепочек, прикладные задачи оперирования верфей стали слишком сложны для интуитивного их решения. В связи с этим за последние несколько десятилетий было сформулировано и в той или иной степени решено множество вариаций \textit{задачи об аллокации верфи}, покрывающих широкий спектр прикладных задач, возникающих в портах по всему миру. Задача динамической аллокации памяти с некоторыми допущениями эквивалентна одной из формулировок этой задачи, а именно вариации $cont|dyn|fix|max(res)$ по классификации обзорной статьи Бирвирта и Мизла\cite{BIERWIRTH2010615}. Решая эту задачу, авторы статей фокусируются на статическом аспекте аллокации, используя глобальные знания о временах аллокации ресурсов. Именно из-за этого задача об аллокации верфи представляет интерес в рамках данной работы.

Одним из первых интересующую нас формулировку задачи об аллокации верфи рассмотрел в своей статье Эндрю Лим\cite{LIM1998105}. Ресурсы, имеющие фиксированные и известные размер и времена аллокации и деаллокации, могут быть рассмотрены как корабли с соответствующей длинной, временем прибытия и временем отплытия, а тип используемой видеопамяти как секция верфи. Задача нахождения минимальной длинны всех секций верфи и точек прибытия всех кораблей аналогична нахождению минимального необходимого объёма памяти и локаций всех ресурсов в этой памяти. Однако, в отличии от рассматриваемой Лимом задачи, ресурсы не накладывают требований на отступ между друг другом и началом или концом верфи, зато требуют определённого выравнивания их начала в памяти. Более того, некоторые алгоритмы компьютерной графики требуют доступа к данным ресурса с прошлых кадров, а в ходе разработки фреймграфа для Dagor Engine выяснилось, что среди функционала движка таких алгоритмов большинство. Требование поддерживать аллокацию и переиспользование памяти ресурсов, переживающих границу кадра, заставляет нас считать время циклическим. В терминах задачи о верфи это требование можно сравнить с составлением неизменного расписания работы верфи на неделю, где ни в один момент времени верфь не простаивает. Последние замечание существенно, ведь иначе момент простаивания можно считать началом недели и задача сводится к сформулированной Лимом. Геометрически, циклическое время означает что задача заключается в упаковке прямоугольников на поверхности бесконечного в одну сторону цилиндра, а не бесконечной в одну сторону полосы.


