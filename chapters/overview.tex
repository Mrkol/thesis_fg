\section{Обзор существующих работ}
\subsection{Рантаймы кадровых графов}
Переходя к обзору различных имплементаций рантайма кадровых графов, стоит отметить, что далеко не все компании готовы рассказывать об используемых в их разработках технологиях. Список, приведённый ниже, включает лишь все коммерческие разработки, о которых достоверно известно из открытых источников информации, что архитектура их основана на вычислительном графе.
\subsubsection*{Frostbite}
Первыми идею организации архитектуры рендеринга в приложениях реального времени через вычислительные графы предложили разработчики движка Frostbite в 2017 году \cite{FrostbiteGdcTalk}.
\textit{Кадровый граф} позволил им сделать ядро модуля рендеринга расширяемым, упростил работу с асинхронным вычислениями общего назначения на GPU, автоматизировал работу со специализированными видами оперативной видеопамяти на игровых консолях, а также сэкономил большое количество обычной видеопамяти.
В силу проприетарности движка неизвестно, насколько широкий класс сценариев использования ресурсов она поддерживает.
В качестве схемы аллокации ресурсов же был взят обычный интерактивный аллокатор, располагающий в заранее выделенном крупном участке памяти ресурсы по мере необходимости.
Автоматическая расстановка барьеров на 2017 год не поддерживалась.

\subsubsection*{Halcyon}
Далее, в 2019 году, компания EA представила \cite{HalcyonRapidInnovationTalk} новый экспериментальный движок Halcyon, обобщающий идею кадрового графа до \textit{графа рендеринга}.
Как следует из названия, это обобщение позволяет организовывать в виде графа вычислений не только процесс рендеринга самого кадра, но и рендеринг различных вспомогательных изображений, например, кубических карт для некоторых техник глобального освещения, изображений импосторов \cite{10.1145/199404.199420}, или различных иконок в приложении.
Более того, граф рендеринга может состоять из нескольких подграфов, запускающихся с разной частотой, например, подграф, вычисляющий тени от солнца, может запускаться только при значительном изменении положения солнца на небе.
В отличие от Frostbite, граф Halcyon поддерживает автоматическую расстановку барьеров.
Также на выступлении отмечается, что изначально граф составлялся явной композицией вершин и подграфов, но в итоге разработчики пришли к дизайну с автоматической композицией вершин на основе глобально видимых имён ресурсов.
Про алгоритм аллокации ресурсов и поддержку переживающих границу кадра ресурсов публично доступной информации нет.

Наконец, граф рендеринга Halcyon способен в автоматическом режиме масштабироваться на несколько аппаратных графических ускорителей, и даже на несколько компьютеров.
Поддержка такого функционала весьма сложна и говорит об экспериментальности этой разработки, так как на практике такая масштабируемость редко применима.

\subsubsection*{Unreal Engine}
Начиная с версии 4.22 в Unreal Engine начал переходить на рендеринг через систему <<Render Dependency Graph>> \cite{UERenderDependencyGraph}, представляющую собой граф рендеринга.
Однако даже в пятой версии движка эта система использует жадную интерактивную стратегию аллокации ресурсов, хоть и поддерживает большое количество важного функционала: автоматизацию асинхронных вычислений на GPU, расстановку барьеров и параллелизацию исполнения графа.

\subsubsection*{Unity}
Разработчики движка Unity, следуя общему направлению индустрии, в 2018 году перевели архитектуру рендеринга на подход вычислительных графов \cite{UnityRenderingArchitectureTalk}.
Однако среди прочих проприетарных движков про граф рендеринга Unity известно, пожалуй, меньше всего.
Отметить стоит лишь наличие интеграции между нативным и скриптовым кодом рендеринга, позволяющей сократить время итерации при разработке приложений.

\subsubsection*{Anvil}
Движок Anvil компании Ubisoft с переходом на DirectX12 тоже начал выделять подсистему зависимостей ресурсов, хоть и не называя её графом кадра \cite{DX12CaseStudies, AnvilDx12LessonsLearned}.
Согласно выступлениям на GDC, эта система поддерживает многий функционал уже упомянутых: переиспользует память ресурсов, автоматически расставляет барьеры, автоматизирует асинхронные вычисления.
Но, как и в случае Unity, детали устройства этой разработки отсутствуют в публичном доступе.

\subsubsection*{Render Pipeline Shaders}
Выпущенная в открытый доступ \cite{RPSgithub} в декабре 2022 года библиотека Render Pipeline Shaders компании AMD в своём составе имеет комплексное решение для построения кадровых графов \cite{RPSpost}.
Эта библиотека почти полностью скрывает от пользователя управление транзиентными ресурсами посредством предметно"=ориентированного языка <<RPSL>>, автоматически переиспользуя память, расставляя барьеры и клонируя объявленные единожды вершины графа. Разработанное AMD решение также поддерживает стандартный функционал кадровых графов: экономия памяти посредством интерактивного алгоритма аллокации, расстановку барьеров и асинхронные вычисления. Наибольшим его преимуществом, вероятно, является исходный открытый код. Недостатком этой разработки является отсутствие переиспользования памяти \textit{темпоральных} ресурсов. В терминах данной работы, любые ресурсы, чья история была запрошена, исключаются из алгоритма аллокации и хранятся в отдельных аллокациях.

\subsubsection*{Granite}
Наконец, стоит упомянуть о существовании многих любительских проектов по написанию обобщённой библиотеки кадровых графов. Большинство из них находятся на стадии зарождения и не заслуживают подробного рассмотрения.
Исключением является проект Granite \cite{GraniteBlogPost}, в рамках которого разработан кадровый граф, адаптированный для использования на мобильных устройствах посредством API Vulkan.
Кадровый граф Granite автоматически расставляет примитивы синхронизации, группирует вершины в рендер"=пассы \cite[раздел~8]{VulkanSpec}, оптимизирует порядок исполнения вершин с точки зрения минимизации накладных расходов на синхронизацию, а также переиспользует память, хоть и при помощи жадного алгоритма аллокации.

\subsection{Аллокация ресурсов}
Задача поиска расписания аллокации ресурсов в графе кадра в своей простейшей формулировке является классической сильно NP-сложной \cite{DSAnpcomplete} задачей \textit{динамической аллокации памяти} (dynamic storage allocation, DSA \cite[с. 226]{10.5555/574848}).
У этой задачи существует две интерпретации, интерактивная и неинтерактивная.
Первая подразумевает обработку разнесённых во времени запросов на аллокацию и деаллокацию ресурсов, иначе говоря, решения об адресах ресурсов в памяти необходимо принимать в порядке времён появления ресурсов.
Этот частный случай часто встречается в операционных системах и рантаймах языков программирования.
Вторая же интерпретация подразумевает наличие заранее известных времён жизни всех ресурсов.
В рамках данной работы нас интересует именно неинтерактивная интерпретация, поэтому, в отсутствие уточнения, под задачей о динамической аллокации памяти мы будем подразумевать именно её.

Одним из первых полиномиальных алгоритмов, предложенных для решения задачи DSA, является алгоритм First-Fit \cite{chrobak_packing_1988}, работающий, как было вскоре доказано Кирстедом, с константной ошибкой не более чем в 80 раз \cite{kierstead_linearity_1988}.
Тремя годами позже Кирстед представил алгоритм с ошибкой не более чем в 6 раз \cite{kierstead_polynomial_1991}.
Эти и другие ранние работы объединяет общий подход сведения DSA к частному случаю с единичным размером всех ресурсов, эквивалентному покраске интервального графа, и последующим применением интерактивного алгоритма покраски.
Через несколько лет Йордан Гергов, отказавшись от сведения к интервальным графам, смог понизить верхнюю оценку минимальной возможной ошибки до 5 \cite{gergov_approximation_1996}, а впоследствии и до 3 \cite{gergov_algorithms_1999}.
Наконец, наилучший на данный момент результат был получен исследователями из AT\&T Labs совместно с коллегой из Ecole Polytechnique \cite{buchsbaum_opt_2003}: полиномиальный алгоритм, для любого заранее выбранного $\varepsilon$ дающий $(2+\varepsilon)$-приблизительное решение DSA.
Более того, для некоторых частных случаев авторы предоставляют приближённую схему полиномиального времени (то есть $(1+\varepsilon)$-приближение).
Из них в рамках графа кадра особо интересна схема для случая ресурсов, размер которых ограничен сверху константой $h_{max}$.
Однако практичность представленных алгоритмов в рамках приложений реального времени является открытым вопросом в силу их высокой сложности, а также асимптотического характера теоретических оценок ошибки.
