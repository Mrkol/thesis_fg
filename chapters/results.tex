\section{Результаты}
В процессе выполнения данной работы в рамках движка Dagor было реализовано предложенное решение в виде библиотеки рантайма кадровых графов <<daBFG>>, занимающей 13828 строк кода на языке C++, а также была произведена частичная интеграция этой библиотеки в существующие проекты, основанные на этом движке.
Так как масштаб кода отрисовки этих проектов невероятно велик, интеграция производится итеративно.
В результате изначальной интеграции, проведённой автором работы, было выделено около 30 вершин и порядка 10 ресурсов.
С тех пор к усилиям по интеграции присоединились и другие разработчики, и на данный момент в проекте Enlisted на максимальных настройках кадровый граф состоит из 84 вершин и отслеживает 74 ресурса, 27 из которых расположены в видеопамяти, управляемой самим рантаймом (остальные "--- CPU-ресурсы и внешний ресурсы).
Отметим, что более чем у половины из имеющихся ресурсов запрашивается история хотя бы одной вершиной.
Также стоит заметить, что некоторые проекты поддерживают работу в VR, что удваивает количество физических ресурсов, а также один из проектов поддерживает скриншоты в высоком качестве, что за счёт использования SSAA x4 и увеличения разрешения скриншота в 2 раза, посредством мультиплексирования увеличивает количество физических ресурсов в 64 раза.
Работа над интеграцией различных частей кода в кадровый граф продолжается, поэтому чтобы оценить качество разработанного решения управления памятью были использованы синтетические тесты.

\subsection*{Синтетические тесты}
В рамках работы над интеграцией решения в Dagor было замечено, что экземпляры задачи CDSA получаемые из временных ресурсов графических приложений обладают определённой структурой.
Например, б\'ольшая часть ресурсов является текстурами, чьё разрешение кратно разрешению пользовательского монитора.
Также, может показаться, что запрос истории ресурса "--- не самая частая операция.
Однако, как уже было сказано выше, среди ресурсов, чья память управляется кадровым графом, таких, чья история запрашивается, на данный момент больше половины.
Чтобы учесть эту специфику в синтетических тестах, был применён статистический метод \textit{бутстрэпа}.

Метода бутстрэпа заключается в генерации повторной выборки б\'ольшего размера из эмпирического распределения имеющейся небольшой выборки.
В качестве выборки были выбраны следующие параметры: количество моментов времени $T$, времена жизни ресурсов $\left|\left[l_i, r_i\right)\right|$ и размеры ресурсов $s_i$.
Также предполагается, что эти величины независимы от значений $l_i$, а сами величины $l_i$ распределены равномерно по всем моментам времени.
Эмпирическое распределение этих данных было получено из нескольких проектов, основанных на Dagor, на различных настройках качества графики.

В качестве базового метода был выбран распространённый в других решениях подход к обработке запросов истории ресурсов: ресурсы, история которых запрашивается хоть единажды, хранятся отдельно от всех остальных, и их память никогда не переиспользуется, а для остальных ресурсов решается задача DSA посредством жадного аллокатора реального времени.

Метрика для сравнения алгоритмов была заимоствована из предыдущих работ по приближённому решению задачи DSA, $makespan/LOAD$, где \textit{общая нагрузка} определяется как максимум нагрузок по всем моментам времени, $LOAD = \max_t L(t)$.
Эта метрика хорошо подходит для исследования DSA, так как $LOAD$ служит нижней границей для $makespan$, хотя часто и недостежимой.
Заметим, что в случае CDSA, несложно привести пример последовательности входных данных задачи с увеличивающимся количеством ресурсов такой, что $makespan/LOAD \geqslant 3/2$ для каждого элемента последовательности, см. \cite{myarticle}.
На практике, однако, подобные эффекты не возникают.

Результаты сравнений представлены на рисунке \ref{fig:results} в виде зависимости метрики $makespan/LOAD$ от количества ресурсов, где для каждого количества ресурсов замеры производились на 2000 различных синтетических тестах.
\begin{figure*}
\centering
\begin{tikzpicture}
\begin{axis}[
    width=0.9\textwidth,
    xlabel={Количество ресурсов},
    ylabel=$makespan/LOAD$,
    legend pos=north west,
    ymin=1,
    ymax=1.6,
    xmin=0,
    xmax=1650
]
\addlegendentry{Среднее, предложенный метод}
\addplot[mark=none,red] table[x=cnt, y=avg, col sep=comma]{results.csv};
\addlegendentry{90я перцентиль, предложенный метод}
\addplot[mark=none,green] table[x=cnt, y=p90, col sep=comma]{results.csv};
\addlegendentry{Среднее, базовый метод}
\addplot[mark=none,blue] table[x=cnt, y=badavg, col sep=comma]{results.csv};
\addlegendentry{90я перцентиль, базовый метод}
\addplot[mark=none,black] table[x=cnt, y=badp90, col sep=comma]{results.csv};
\end{axis}
\end{tikzpicture}
\caption{Замеры качества предложенной схемы решения CDSA по метрике $makespan/LOAD$, меньше "--- лучше.
Значения аккумулированы по 2000 запускам на синтетических тестах, полученных из реальных данных методом бутстрэпа.}
\label{fig:results}
\end{figure*}
%
\begin{figure*}
\centering
\begin{tikzpicture}
\begin{axis}[
    width=0.9\textwidth,
    height=0.3\textheight,
    xlabel={Количество ресурсов},
    ylabel=$makespan/LOAD$,
    legend pos=north east,
    ymin=1.09,
    ymax=1.175,
    xmin=100,
    xmax=1600,
]
\addlegendentry{Среднее, предложенный метод}
    \addplot[mark=none,red] table[x=cnt, y=avg, col sep=comma]{results.csv};
\addlegendentry{90я перцентиль, предложенный метод}
    \addplot[mark=none,green] table[x=cnt, y=p90, col sep=comma]{results.csv};
%
\addplot[black, thick] table[
    col sep=comma,
    y={create col/linear regression={y=avg}}
    ] {results_truncated.csv};
\addplot[black, thick] table[
    col sep=comma,
    y={create col/linear regression={y=p90}}
    ] {results_truncated.csv};
\end{axis}
\end{tikzpicture}
\caption{Графики предлагаемого решения из рис. \ref{fig:results} в увеличенном масштабе.}
\label{fig:resultsTrend}
\end{figure*}
Из рисунка \ref{fig:results} видно, что базовый метод ведёт к росту метрики с количеством ресурсов как в среднем так и в худшем случае.
Предложенное решение же приводит к убыванию метрики к асимптоте в районе 1.1, как в среднем, так и в худшем случае, что лучше видно на рисунке \ref{fig:resultsTrend}.
Подобный тренд полагает судить, что чем больше временных ресурсов движка Dagor интегрировано в кадровый граф, тем меньше будет управление их памятью отличатся от оптимального.
Оптимальное же отношение $makespan/LOAD$ находится в интервале $[1, 1.1]$, но нахождение этого оптимума не представляется возможным в силу $\NP$-полноты задачи.

Наконец стоит отметить, что предложенное решение не гарантирует ограниченности метрики $makespan/LOAD$ в асимптотическом смысле.
Иначе говоря, алгоритм имеет неограниченную ошибку относительно оптимального ответа.
Достаточно рассмотреть последовательность входов размера $n$ следующего вида, $T = n + 2$, $l_i = i$, $r_i = i + 2$, $i = \overline{0,n}$, при этом такую, что $\forall j,\;\sum_{i=0}^{j-2} s_i < s_j$ и $s_{j-1} < s_j$.
По индукции, при поиске блока для очередного ресурса $i$ будет доступен лишь единственный блок размера $\sum_{j=1}^{i-2} s_j$, по построению не достаточный для размещения ресурса $i$.
Следовательно, ресурсы будут расположены в памяти последовательно, а итоговый ответ $makespan = \sum_{i=0}^n s_i$.
Однако если рассмотреть эквивалентный экземпляр CDSA, в котором время повёрнуто вспять, алгоритм найдёт решение с $makespan = s_n + s_{n-1} = LOAD$, являющееся оптимальным.
Отношение $\left(\sum_{j=1}^{n} s_j\right)/\left(s_n + s_{n-1}\right)$ можно сделать сколь угодно большим, выбрав подходящее значение $s_i$, например, $2^{2^i}$, а значит и ошибка алгоритма не ограничена.
