\section{Предложенное решение}
\subsection{Общая архитектура}
Кадровый граф в первую очередь состоит из вершин, каждая из которых в свою очередь состоит из имени и функций \textit{объявления} и \textit{запуска}, задаваемых пользователем рантайма.
Как следует из названия, функция запуска вызывается рантаймом в момент исполнения кадрового графа для записи командных списков, а функция объявления вызывается при перекомпиляции графа чтобы предоставить пользователю возможность установить следующие скрытые свойства вершины:
\begin{itemize}
    \item ресурсные и вершинные зависимости,
    \item назначения ресурсов,
    \item режим \textit{мультиплексирования} вершины,
    \item флаг наличия побочных эффектов,
    \item требуемое для запуска вершины состояние драйвера.
\end{itemize}
Пользователь может в любой момент создать, удалить или изменить вершину, на что рантайм автоматически отреагирует на ближайшем запуске кадрового графа.
Все существующие в программе вершины вершины организуются в единую структуру называемую кадровым графом, но в строгом математическом смысле кадровым графом не являющуюся.

Каждый кадр приложения пользователь даёт команду рантайму запустить текущий граф.
Перед тем как исполнить эту команду, рантайм проверяет не изменился ли граф с прошлого запуска, и в случае изменения начинает процесс \textit{компиляции графа}, состоящий из следующих пунктов:
\begin{enumerate}
    \item объявление вершин,
    \item генерация промежуточного представления,
    \item построение расписания вершин,
    \item построение расписания ресурсов,
    \item активация \textit{истории ресурсов}.
\end{enumerate}
Помимо вершин, кадровый граф содержит в себе некоторую вспомогательную информацию, при изменении которой нет нужды полностью перекомпилировать граф, поэтому процесс компиляции является инкрементальным.
Так, например, при изменении разрешении окна, процесс перекомпиляции графа начнётся с предпоследнего пункта.
Первый этап компиляции же запускается всякий раз когда пользователь изменил множество вершин, и именно в рамках этого этапа запускаются функции объявления изменившихся вершин.

Как уже было сказано выше, данные, изначально задаваемые пользователем рантайма, строго говоря не являются графом, а лишь схемой получения графа \textit{промежуточного представления}, с которым и работает остальной рантайм.
\todo{диаграмма?}
Данные, полученные от пользователя, могут быть невалидными и противоречивыми, поэтому в процессе получения промежуточного представления также идёт валидация, и гарантируется, что получившийся граф будет удовлетворять следующему определению.
\textit{Граф промежуточного представления}~--- пятёрка $(V, E, R, U, H)$, где $(V, E)$~--- вершины и рёбра ориентированного ациклического графа, $R$~--- множество ресурсов, функция $U : V \to 2^R$ задаёт множество используемых каждой вершиной ресурсов, а функция $H : V \to 2^R$ задаёт множество ресурсов, чью историю использует вершина.
При этом требуется, чтобы для любого $r\in R$ подграф $(V, E)$ индуцированный множеством $\left\{v \in V \middle| r \in U(v)\right\}$ был непустым слабо-связным графом с ровно одной вершиной с входной степенью $0$.

На этапе построения расписания вершин строится топологическая сортировка промежуточного графа.
В теории, именно на этом этапе может строится многопоточное расписание запуска функций исполнения вершин, а также могут выбираться разные очереди GPU для отправки команд исполняемыми вершинами.
Однако, на практике, работа в этом направлении требует крупных предварительных вложений времени в сугубо инженерные вопросы, что не было предусмотрено в рамках бюджета данной работы.

Эти и оставшиеся этапы, а также конкретные возможности разработанного решения, более подробно рассмотрены в следующих подразделах.

\subsection{Зависимости вершин}
Под ресурсами и вершинами как элементами множеств тут и в дальнейшем будем понимать их уникальные строковые идентификаторы, задаваемый пользователем рантайма.
У каждой вершины $v$, среди прочих, есть следующий набор скрытых свойств, устанавливаемых через функцию декларации:
\begin{itemize}
    \item множества предшествующих и последующих вершин $P_v$ и $F_v$,
    \item множество создаваемых ресурсов $C_v$,
    \item множество читаемых ресурсов $R_v$,
    \item множество изменяемых ресурсов $M_v$,
    \item множество пар переименования ресурсов $E_v$.
\end{itemize}
Именно на основании этих свойств рантайм генерирует рёбра в промежуточном графе по следующим правилам.
Ребро из вершины $v$ в вершину $u$ проводится тогда и только тогда, когда верно хотя бы одно из следующих утверждений:
\begin{itemize}
    \item $v\in P_u$,
    \item $u\in F_v$,
    \item $r \in C_v$ и $r \in M_u$,
    \item $r \in M_v$ и $r \in R_u$,
    \item $r \in R_v$ и $\exists r',\;(r, r') \in E_u$,
    \item $\exists r',\;(r', r) \in E_v$ и $r \in M_u$.
\end{itemize}
Иначе говоря, рантайм гарантирует, что создание ресурса произойдёт раньше, чем все модификации, каждая из модификаций произойдёт раньше, чем каждое чтение, и наконец каждое чтение произойдёт раньше, чем переименование.
При этом само переименование считается моментом создания нового ресурса, соответствующего новому имени.
Если в процессе генерации промежуточного представления из пользовательских вершин получается граф с циклами, либо какой-то ресурс создаётся более чем одной вершиной (считая переименования), рантайм оповещает пользователя об ошибке и предпринимает самостоятельную попытку исправить итоговый граф путём игнорирования некоторых вершин или рёбер.

При генерации промежуточного представления, информация о переименовывании стирается.
Так, одному ресурсу из множества $R$ промежуточного графа может соответствовать несколько различных имён ресурсов, указанных пользователем.

Подобная система упорядочивания гарантирует расширяемость и модульность приложений.Основной компонент приложения может составить \textit{скелетный} кадровый граф, не отображающий ничего, но задающий базовую структуру рендеринга.
\todo{схемка?}
Далее, различные модули приложения могут встраиваться в этот скелет, читая и модифицируя различные ресурсы.

\subsection{История ресурсов}
В процессе интеграции одной из ранних версий рантайма кадровых графов, было выяснено, что огромное количество алгоритмов визуализации в целевом приложении использует понятие \textit{истории ресурса}: требуется чтение данных конкретного ресурса в том виде, в котором они находились на конец предыдущего кадра.

Для поддержки таких алгоритмов было введено разделение на \textit{логические} и \textit{физические} ресурсы, где первые представляют собой строковые имена задаваемые пользователем рантайма, а последние~--- регионы памяти GPU, с которыми работают функции запуска вершин.
Для каждого логического ресурса кадрового графа создаётся два физических ресурса, предоставляемых пользователю поочерёдно на чётных и нечётных кадрах.
Это позволяет вершинам, представляющим такие алгоритмы как темпоральное сглаживание \cite{yang2020survey}, одновременно читать историю ресурса и писать сам ресурс.

В дополнение вышеперечисленным множествам запрашиваемых ресурсов каждая вершина содержит множество $H_v$ ресурсов, чья история требуется для выполнения вершины.
Запрос истории с точки зрения упорядочивания вершин приравнивается к чтению, что делает невозможным запрос истории ресурсов, переименуемых в процессе исполнения кадра.

Насколько известно автору, разработанное решение~--- первый рантайм кадровых графов, поддерживающий запросы истории ресурсов, а также способный переиспользовать память ресурсов, чья история запрашивается хотя бы одной вершиной.

\subsection{Мультиплексирование}
Следующая проблема, возникшая в процессе интеграции рантайма~--- необходимость запускать некоторые вершины кадрового графа несколько раз в рамках одного кадра.
Возникает такая необходимость в следующих ситуациях:
\begin{itemize}
    \item запуск приложения на устройстве виртуальной реальности, где вид с основной камеры необходимо рендерить для каждого дисплея заново (от 2 до 4 в зависимости от устройства);
    \item поддержка скриншотов в высоком разрешении, где скриншот рендерится по-частям, чтобы не превысить бюджет видеопамяти на потребительских GPU;
    \item поддержка алгоритма SSAA \todo{ссылка};
    \item поддержка локальной многопользовательской игры, где экран делится пополам, и на разных половинах отображается ракурс разных игроков.
\end{itemize}
Для поддержки этих ситуаций в предлагаемом решении введён механизм \textit{мультиплексирования} вершин и ресурсов.

Вводится размерность мультиплексирования, $D$.
Каждая вершина посредством функции декларации указывает свой \textit{режим мультиплексирования}, элемент $\mathbb{Z}_2^D$, являющийся булевой маской выбора измерений.
На режимах мультиплексирования вводится частичный порядок: для $a,b\in\mathbb{Z}_2^D$, $a \preceq b$, если $\forall i,\;a_i \leqslant b_i$.
Каждому ресурсу ставится в соответствие режим мультиплексирования той вершины, которая его создаёт.
Если вершина с режимом $a$ запрашивает ресурс с режимом $b$, то от пользователя требуется, чтобы $b \preceq a$, так как иная ситуация ведёт к неоднозначности выбора физического ресурса.
Также при $u \in P_v$ или $u \in F_v$ требуется, чтобы режимы $u$ и $v$ были сравнимы в частичном порядке $\preceq$.

Перед запуском графа, от пользователя требуется предоставить рантайму $c \in \mathbb{Z}_{>0}^D$.
Во время генерации промежуточного представления, для вершины с режимом $a$ будет создано $\prod_{i=1}^{D} c_i^{a_i}$ вершин  промежуточных промежуточного графа, и аналогично для ресурсов.
Правила проведения рёбер в промежуточном графе обобщаются со случая $c = \left(1, \dots, 1\right)$ естественным образом в силу ограничения из предыдущего абзаца.

Предлагаемая система мультиплексирования покрывает все описанные выше случаи.
Рассмотрим, например, приложение, работающее на VR-устройстве с двумя дисплеями, и использующее алгоритмом сглаживания SSAA x4
Выберем $D = 2$ и $c = (2, 4)$, где первое измерение будет отвечать номеру дисплея, а второе~--- количеству суперпикселей.
Все вершины приложения, визуализирующие вид с основной камеры, должны быть помечены режимом $(1, 1)$.
Вершины же, например, вычисляющие тени, должны быть помечены режимом $(0, 0)$, так как одна и та же карта теней может быть использована для обоих глаз и всех суперпикселей.

\subsection{Автоматические разрешения текстур}
Большие неудобства при разработке графических приложений составляет смена разрешения экрана.
Большинство транзиентных ресурсов представляют собой текстуры, разрешение которых кратно разрешению окна приложения, что делает целесообразным разработку централизованного механизма реакции на смену разрешения экрана.

Таким механизмом в предлагаемом решении являются \textit{авторазрешения}.
В вершине, создающей транзиентную текстуру, пользователь рантайма вместо конкретного разрешения может указать строковой идентификатор авторазрешения, числовое значение соответствующее которому сообщается рантайму извне, как правило в коде реакции на смену разрешения окна.
Рантайм, обнаружив на очередном кадре, что одно из авторазрешений поменялось, построит новое расписание ресурсов, тем самым изменяя разрешения физических ресурсов прозрачно для пользователя.

Также система авторазрешений предлагаемого решения поддерживает \textit{динамическую смену разрешений}.
Обнаружив низкую частоту кадров, приложение может уменьшить разрешение, в котором рисуются кадры, чтобы увеличить производительность.
Рантайм кадровых графов в свою очередь позволяет уменьшать разрешения всех текстур с производительностью достаточной чтобы делать это каждый кадр, не освобождая при этом, однако, неиспользуемую память.

\subsection{Расстановка барьеров}
Как уже было упомянуто ранее, современные графические API требуют от пользователя в ручную отслеживать использование ресурсов и расставлять в соответствии со спецификацией необходимые ресурсные барьеры.

В разработанном решении для каждого ресурса, встречающегося в множествах $C_v,$ $R_v$, $M_v$, $E_v$ и $H_v$, в вершине хранится пометка о том, как именно в рамках её функции запуска будет использоваться ресурс
Эта информация сохраняется при переходе к промежуточному представлению, и в момент построения расписания ресурсов рантайм в соответствии с этими пометками расставляет так называемые \textit{раздельные барьеры} \cite[раздел~7.5]{VulkanSpec}, позволяющие GPU самостоятельно выбирать подходящий момент времени для выполнения служебной работы по управлению кешами и состояниями ресурсов.

Как будет видно в последующих разделах, необходимость указывать способ использования каждого ресурса в каждой вершине не доставляет больших неудобств пользователям благодаря разработанному публичному API рантайма.

\subsection{Однородная поддержка ресурсов CPU}
\todo{блобы}

\subsection{Прореживание и валидация кадрового графа}
\todo{про прунинг, удаление неволидных ветвей, опциональные ресурсы}

\subsection{Управление глобальным состоянием}
\todo{про биндинг шейдерваров, матриц, рендертаргетов}

\subsection{Пользовательское API рантайма}
\todo{тут отрывочки кода, как оно выглядит}

\subsection{Построение расписания ресурсов}
\todo{тут мясо про CDSA}
