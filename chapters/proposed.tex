\section{Предложенное решение}
\subsection{Архитектура решения}
\subsubsection{Общая архитектура}
Кадровый граф в первую очередь состоит из вершин, каждая из которых в свою очередь состоит из имени и функций \textit{объявления} и \textit{запуска}, задаваемых пользователем рантайма.
Как следует из названия, функция запуска вызывается рантаймом в момент исполнения кадрового графа для записи командных списков, а функция объявления вызывается при перекомпиляции графа чтобы предоставить пользователю возможность установить следующие скрытые свойства вершины:
\begin{itemize}
    \item ресурсные и вершинные зависимости,
    \item назначения ресурсов,
    \item режим \textit{мультиплексирования} вершины,
    \item флаг наличия побочных эффектов,
    \item требуемое для запуска вершины состояние драйвера.
\end{itemize}
Пользователь может в любой момент создать, удалить или изменить вершину, на что рантайм автоматически отреагирует на ближайшем запуске кадрового графа.
Все существующие в программе вершины вершины организуются в единую структуру называемую кадровым графом, но в строгом математическом смысле кадровым графом не являющуюся.

Каждый кадр приложения пользователь даёт команду рантайму запустить текущий граф.
Перед тем как исполнить эту команду, рантайм проверяет не изменился ли граф с прошлого запуска, и в случае изменения начинает процесс \textit{компиляции графа}, состоящий из следующих пунктов:
\begin{enumerate}
    \item объявление вершин,
    \item генерация промежуточного представления,
    \item построение расписания вершин,
    \item построение расписания ресурсов,
    \item активация \textit{истории ресурсов}.
\end{enumerate}
Помимо вершин, кадровый граф содержит в себе некоторую вспомогательную информацию, при изменении которой нет нужды полностью перекомпилировать граф, поэтому процесс компиляции является инкрементальным.
Так, например, при изменении разрешении окна, процесс перекомпиляции графа начнётся с предпоследнего пункта.
Первый этап компиляции же запускается всякий раз когда пользователь изменил множество вершин, и именно в рамках этого этапа запускаются функции объявления изменившихся вершин.

Как уже было сказано выше, данные, изначально задаваемые пользователем рантайма, строго говоря не являются графом, а лишь схемой получения графа \textit{промежуточного представления}, с которым и работает остальной рантайм.
\todo{диаграмма?}
Данные, полученные от пользователя, могут быть невалидными и противоречивыми, поэтому в процессе получения промежуточного представления также идёт валидация, и гарантируется, что получившийся граф будет удовлетворять следующему определению.
\textit{Граф промежуточного представления}~--- пятёрка $(V, E, R, U, H)$, где $(V, E)$~--- вершины и рёбра ориентированного ациклического графа, $R$~--- множество ресурсов, функция $U : V \to 2^R$ задаёт множество используемых каждой вершиной ресурсов, а функция $H : V \to 2^R$ задаёт множество ресурсов, чью историю использует вершина.
При этом требуется, чтобы для любого $r\in R$ подграф $(V, E)$ индуцированный множеством $\left\{v \in V \middle| r \in U(v)\right\}$ был непустым слабо-связным графом с ровно одной вершиной с входной степенью $0$.

На этапе построения расписания вершин строится топологическая сортировка промежуточного графа.
В теории, именно на этом этапе может строится многопоточное расписание запуска функций исполнения вершин, а также могут выбираться разные очереди GPU для отправки команд исполняемыми вершинами.
Однако, на практике, работа в этом направлении требует крупных предварительных вложений времени в сугубо инженерные вопросы, что не было предусмотрено в рамках бюджета данной работы.

Эти и оставшиеся этапы, а также конкретные возможности разработанного решения, более подробно рассмотрены в следующих подразделах.

\subsubsection{Зависимости вершин}
Под ресурсами и вершинами как элементами множеств тут и в дальнейшем будем понимать их уникальные строковые идентификаторы, задаваемый пользователем рантайма.
У каждой вершины $v$, среди прочих, есть следующий набор скрытых свойств, устанавливаемых через функцию декларации:
\begin{itemize}
    \item множества предшествующих и последующих вершин $P_v$ и $F_v$,
    \item множество создаваемых ресурсов $C_v$,
    \item множество читаемых ресурсов $R_v$,
    \item множество изменяемых ресурсов $M_v$,
    \item множество пар переименования ресурсов $E_v$.
\end{itemize}
Именно на основании этих свойств рантайм генерирует рёбра в промежуточном графе по следующим правилам.
Ребро из вершины $v$ в вершину $u$ проводится тогда и только тогда, когда верно хотя бы одно из следующих утверждений:
\begin{itemize}
    \item $v\in P_u$,
    \item $u\in F_v$,
    \item $r \in C_v$ и $r \in M_u$,
    \item $r \in M_v$ и $r \in R_u$,
    \item $r \in R_v$ и $\exists r',\;(r, r') \in E_u$,
    \item $\exists r',\;(r', r) \in E_v$ и $r \in M_u$.
\end{itemize}
Иначе говоря, рантайм гарантирует, что создание ресурса произойдёт раньше, чем все модификации, каждая из модификаций произойдёт раньше, чем каждое чтение, и наконец каждое чтение произойдёт раньше, чем переименование.
При этом само переименование считается моментом создания нового ресурса, соответствующего новому имени.
Если в процессе генерации промежуточного представления из пользовательских вершин получается граф с циклами, либо какой-то ресурс создаётся более чем одной вершиной (считая переименования), рантайм оповещает пользователя об ошибке и предпринимает самостоятельную попытку исправить итоговый граф путём игнорирования некоторых вершин или рёбер.

При генерации промежуточного представления, информация о переименовывании стирается.
Так, одному ресурсу из множества $R$ промежуточного графа может соответствовать несколько различных имён ресурсов, указанных пользователем.

Подобная система упорядочивания гарантирует расширяемость и модульность приложений.Основной компонент приложения может составить \textit{скелетный} кадровый граф, не отображающий ничего, но задающий базовую структуру рендеринга.
\todo{схемка?}
Далее, различные модули приложения могут встраиваться в этот скелет, читая и модифицируя различные ресурсы.

\subsubsection{История ресурсов}
В процессе интеграции одной из ранних версий рантайма кадровых графов, было выяснено, что огромное количество алгоритмов визуализации в целевом приложении использует понятие \textit{истории ресурса}: требуется чтение данных конкретного ресурса в том виде, в котором они находились на конец предыдущего кадра.

Для поддержки таких алгоритмов было введено разделение на \textit{логические} и \textit{физические} ресурсы, где первые представляют собой строковые имена задаваемые пользователем рантайма, а последние~--- регионы памяти GPU, с которыми работают функции запуска вершин.
Для каждого логического ресурса кадрового графа создаётся два физических ресурса, предоставляемых пользователю поочерёдно на чётных и нечётных кадрах.
Это позволяет вершинам, представляющим такие алгоритмы как темпоральное сглаживание \cite{yang2020survey}, одновременно читать историю ресурса и писать сам ресурс.

В дополнение вышеперечисленным множествам запрашиваемых ресурсов каждая вершина содержит множество $H_v$ ресурсов, чья история требуется для выполнения вершины.
Запрос истории с точки зрения упорядочивания вершин приравнивается к чтению, что делает невозможным запрос истории ресурсов, переименуемых в процессе исполнения кадра.

Насколько известно автору, разработанное решение~--- первый рантайм кадровых графов, поддерживающий запросы истории ресурсов, а также способный переиспользовать память ресурсов, чья история запрашивается хотя бы одной вершиной.

\subsubsection{Мультиплексирование}
Следующая проблема, возникшая в процессе интеграции рантайма~--- необходимость запускать некоторые вершины кадрового графа несколько раз в рамках одного кадра.
Возникает такая необходимость в следующих ситуациях:
\begin{itemize}
    \item запуск приложения на устройстве виртуальной реальности, где вид с основной камеры необходимо рендерить для каждого дисплея заново (от 2 до 4 в зависимости от устройства);
    \item поддержка скриншотов в высоком разрешении, где скриншот рендерится по-частям, чтобы не превысить бюджет видеопамяти на потребительских GPU;
    \item поддержка алгоритма SSAA \todo{ссылка};
    \item поддержка локальной многопользовательской игры, где экран делится пополам, и на разных половинах отображается ракурс разных игроков.
\end{itemize}
Для поддержки этих ситуаций в предлагаемом решении введён механизм \textit{мультиплексирования} вершин и ресурсов.

Вводится размерность мультиплексирования, $D$.
Каждая вершина посредством функции декларации указывает свой \textit{режим мультиплексирования}, элемент $\mathbb{Z}_2^D$, являющийся булевой маской выбора измерений.
На режимах мультиплексирования вводится частичный порядок: для $a,b\in\mathbb{Z}_2^D$, $a \preceq b$, если $\forall i,\;a_i \leqslant b_i$.
Каждому ресурсу ставится в соответствие режим мультиплексирования той вершины, которая его создаёт.
Если вершина с режимом $a$ запрашивает ресурс с режимом $b$, то от пользователя требуется, чтобы $b \preceq a$, так как иная ситуация ведёт к неоднозначности выбора физического ресурса.
Также при $u \in P_v$ или $u \in F_v$ требуется, чтобы режимы $u$ и $v$ были сравнимы в частичном порядке $\preceq$.

Перед запуском графа, от пользователя требуется предоставить рантайму $c \in \mathbb{Z}_{>0}^D$.
Во время генерации промежуточного представления, для вершины с режимом $a$ будет создано $\prod_{i=1}^{D} c_i^{a_i}$ вершин  промежуточных промежуточного графа, и аналогично для ресурсов.
Правила проведения рёбер в промежуточном графе обобщаются со случая $c = \left(1, \dots, 1\right)$ естественным образом в силу ограничения из предыдущего абзаца.

Предлагаемая система мультиплексирования покрывает все описанные выше случаи.
Рассмотрим, например, приложение, работающее на VR-устройстве с двумя дисплеями, и использующее алгоритмом сглаживания SSAA x4
Выберем $D = 2$ и $c = (2, 4)$, где первое измерение будет отвечать номеру дисплея, а второе~--- количеству суперпикселей.
Все вершины приложения, визуализирующие вид с основной камеры, должны быть помечены режимом $(1, 1)$.
Вершины же, например, вычисляющие тени, должны быть помечены режимом $(0, 0)$, так как одна и та же карта теней может быть использована для обоих глаз и всех суперпикселей.

\subsubsection{Автоматические разрешения текстур}
Большие неудобства при разработке графических приложений составляет смена разрешения экрана.
Большинство транзиентных ресурсов представляют собой текстуры, разрешение которых кратно разрешению окна приложения, что делает целесообразным разработку централизованного механизма реакции на смену разрешения экрана.

Таким механизмом в предлагаемом решении являются \textit{авторазрешения}.
В вершине, создающей транзиентную текстуру, пользователь рантайма вместо конкретного разрешения может указать строковой идентификатор авторазрешения, числовое значение соответствующее которому сообщается рантайму извне, как правило в коде реакции на смену разрешения окна.
Рантайм, обнаружив на очередном кадре, что одно из авторазрешений поменялось, построит новое расписание ресурсов, тем самым изменяя разрешения физических ресурсов прозрачно для пользователя.

Также система авторазрешений предлагаемого решения поддерживает \textit{динамическую смену разрешений}.
Обнаружив низкую частоту кадров, приложение может уменьшить разрешение, в котором рисуются кадры, чтобы увеличить производительность.
Рантайм кадровых графов в свою очередь позволяет уменьшать разрешения всех текстур с производительностью достаточной чтобы делать это каждый кадр, не освобождая при этом, однако, неиспользуемую память.

\subsubsection{Расстановка барьеров}
Как уже было упомянуто ранее, современные графические API требуют от пользователя в ручную отслеживать использование ресурсов и расставлять в соответствии со спецификацией необходимые ресурсные барьеры.

В разработанном решении для каждого ресурса, встречающегося в множествах $C_v,$ $R_v$, $M_v$, $E_v$ и $H_v$, в вершине хранится пометка о том, как именно в рамках её функции запуска будет использоваться ресурс
Эта информация сохраняется при переходе к промежуточному представлению, и в момент построения расписания ресурсов рантайм в соответствии с этими пометками расставляет так называемые \textit{раздельные барьеры} \cite[раздел~7.5]{VulkanSpec}, позволяющие GPU самостоятельно выбирать подходящий момент времени для выполнения служебной работы по управлению кешами и состояниями ресурсов.

Как будет видно в последующих разделах, необходимость указывать способ использования каждого ресурса в каждой вершине не доставляет больших неудобств пользователям благодаря разработанному публичному API рантайма.

\subsubsection{Однородная поддержка ресурсов CPU}
В начале работы над рантаймом планировалась поддержка лишь GPU ресурсов, однако в процессе интеграции первого прототипа было выяснено, что передача CPU данных, влияющих на запись командных списков, должна тесно взаимодействовать с различными подсистемами рантайма.
В следствии этого было принято решение обобщить механизмы кадровых графов на работу как с данными на GPU, так и с данными на CPU.
Это решение способствует модульности и простоте написания кода новых вершин.
Так, например, матрица преобразования из мирового пространства в экранное пространства, должна отличатся для разных глаз в VR-приложениях.
Чтение этой матрицы во всех вершинах через ресурс кадрового графа позволяет подменить эту матрицу в базовом скелете кадрового графа при адаптации приложения для VR-платформ, не меняя при этом код других вершин.

\subsubsection{Прореживание и валидация кадрового графа}
Как уже было упомянуто выше, в процессе генерации промежуточного представления происходит валидация корректности данных пользователя.

Так, например, возможна ситуация, в которой вершина запрашивает на чтение не произведённый никакой другой вершиной ресурс.
Чтобы предотвратить падения приложения в подобных ситуациях, рантайм находит и исключает из рассмотрения подобные \textit{сломанные} вершины.
Так как сломанная вершина сама могла создавать некоторые ресурсы, в результате этого исключения могут появится новые сломанные вершины, поэтому процедура запускается итеративно, пока находится хотя бы одна сломанная вершина. Однако встречаются ситуации, в которых вершина способна функционировать даже если один из запрашиваемых ресурсов отсутствует. Например, некоторые алгоритмы способны работать с глубиной в различных форматах, предоставляя, однако, разный по качеству результат. Для учёта таких ситуаций запросы ресурсов в вершине могут быть помечены как опциональные, что предотвратит исключение вершины из графа в случае отсутствия соответствующего ресурса.

Возможна и обратная ситуация: запуск вершины может не иметь никаких побочных эффектов кроме создания ресурса, который в итоге не будет использован ни одной другой вершиной.
Чтобы исключить трату вычислительных ресурсов и памяти подобными \textit{висячими} вершинами, рантайм находит и исключает из рассмотрения и их.
Однако, в процессе интеграции рантайма кадровых графов в движок не редко возникали ситуации, в которых побочные эффекты запуска вершины производились незаметно для кадрового графа, в обход системы ресурсов.
Чтобы подобные вершины не выкидывались рантаймом, функция декларации может пометить вершину флагом внешних побочных эффектов.

\subsubsection{Внешние ресурсы}
Некоторые особые виды ресурсов не могут управляться рантаймом кадровых графов, так как само графическое API не предоставляет прямой доступ к ним.
Например, изображения \textit{свопчейна} создаются операционной системой, и хранятся в памяти управляемой ей.
Более того, для интеграции некоторых часто используемых ресурсов движка в кадровый граф требовалось слишком больше количество изменений в коде.
Для постепенной интеграции этих ресурсов, а также поддержки внешних по отношению ко всему приложению ресурсов, в рантайм было добавлено понятие \textit{внешних ресурсов}.
Внешние ресурсы работают аналогично остальным за исключением управления их памятью.
При создании внешнего ресурса, вместо предоставления данных, необходимых для создания подобного ресурса в рамках рантайма, от пользователя требуется предоставить функцию, отображающую текущий \textit{индекс мультиплексирования} в уже существующий физический ресурс.
Здесь, индекс мультиплексирования~--- вектор, описывающий номер запуска вершины в рамках мультиплексирования.
Рантайм в свою очередь запускает эту функцию перед каждым запуском соответствующий вершины, и предоставляет всем последующим вершинам полученный физический ресурс в качестве запрошенного логического.

\subsubsection{Управление глобальным состоянием}
Как правило, перед запуском работы на GPU посредством вызова отрисовки или запуска вычислительного шейдера, необходимо выставить некоторый набор глобальных состояний GPU посредством специальных команд.
Для нескольких подряд идущих вершин, эти команды могут быть абсолютно одинаковыми.
Так, например, при отрисовки G-буффера, набор целевых изображений не будет отличатся между вершинами.
Переключение этих состояний~--- не самая долгая операция, однако переключая их зазря перед каждым вызовом отрисовки всё равно можно значительно замедлить работу приложения.

Чтобы избежать этой ситуации, выставление состояний GPU было интегрировано в рантайм кадровых графов.
Пользователь указывает необходимое на момент запуска состояние в функции декларации, а рантайм находит оптимальную последовательность смены состояний в процессе исполнения графа, минимизируя тем самым накладные расходы.

\subsection{Пользовательское API рантайма}
\todo{тут отрывочки кода, как оно выглядит}

\subsection{Построение расписания ресурсов}
\todo{тут мясо про CDSA}
