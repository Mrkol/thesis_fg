\section{Предложенное решение}
\subsection{Архитектура решения}
\subsubsection{Общая архитектура}
Кадровый граф в первую очередь состоит из вершин, каждая из которых в свою очередь состоит из имени и функций \textit{объявления} и \textit{запуска}, задаваемых пользователем рантайма.
Как следует из названия, функция запуска вызывается рантаймом в момент исполнения кадрового графа для записи командных списков, а функция объявления вызывается при перекомпиляции графа чтобы предоставить пользователю возможность установить следующие скрытые свойства вершины:
\begin{itemize}
    \item ресурсные и вершинные зависимости,
    \item назначения ресурсов,
    \item режим \textit{мультиплексирования} вершины,
    \item флаг наличия побочных эффектов,
    \item требуемое для запуска вершины состояние драйвера.
\end{itemize}
Пользователь может в любой момент создать, удалить или изменить вершину, на что рантайм автоматически отреагирует на ближайшем запуске кадрового графа.
Все существующие в программе вершины вершины организуются в единую структуру называемую кадровым графом, но в строгом математическом смысле кадровым графом не являющуюся.

Каждый кадр приложения пользователь даёт команду рантайму запустить текущий граф.
Перед тем как исполнить эту команду, рантайм проверяет не изменился ли граф с прошлого запуска, и в случае изменения начинает процесс \textit{компиляции графа}, состоящий из следующих пунктов:
\begin{enumerate}
    \item объявление вершин,
    \item генерация промежуточного представления,
    \item построение расписания вершин,
    \item построение расписания ресурсов,
    \item активация \textit{истории ресурсов}.
\end{enumerate}
Помимо вершин, кадровый граф содержит в себе некоторую вспомогательную информацию, при изменении которой нет нужды полностью перекомпилировать граф, поэтому процесс компиляции является инкрементальным.
Так, например, при изменении разрешении окна, процесс перекомпиляции графа начнётся с предпоследнего пункта.
Первый этап компиляции же запускается всякий раз когда пользователь изменил множество вершин, и именно в рамках этого этапа запускаются функции объявления изменившихся вершин.

Как уже было сказано выше, данные, изначально задаваемые пользователем рантайма, строго говоря не являются графом, а лишь схемой получения графа \textit{промежуточного представления}, с которым и работает остальной рантайм.
\todo{диаграмма?}
Данные, полученные от пользователя, могут быть невалидными и противоречивыми, поэтому в процессе получения промежуточного представления также идёт валидация, и гарантируется, что получившийся граф будет удовлетворять следующему определению.
\textit{Граф промежуточного представления} "--- пятёрка $(V, E, R, U, H)$, где $(V, E)$ "--- вершины и рёбра ориентированного ациклического графа, $R$ "--- множество ресурсов, функция $U : V \to 2^R$ задаёт множество используемых каждой вершиной ресурсов, а функция $H : V \to 2^R$ задаёт множество ресурсов, чью историю использует вершина.
При этом требуется, чтобы для любого $r\in R$ подграф $(V, E)$ индуцированный множеством $\left\{v \in V \middle| r \in U(v)\right\}$ был непустым слабо-связным графом с ровно одной вершиной с входной степенью $0$.

На этапе построения расписания вершин строится топологическая сортировка промежуточного графа.
В теории, именно на этом этапе может строится многопоточное расписание запуска функций исполнения вершин, а также могут выбираться разные очереди GPU для отправки команд исполняемыми вершинами.
Однако на практике, работа в этом направлении требует крупных предварительных вложений времени в сугубо инженерные вопросы, что не было предусмотрено в рамках бюджета данной работы.

Эти и оставшиеся этапы, а также конкретные возможности разработанного решения, более подробно рассмотрены в следующих подразделах.

\subsubsection{Зависимости вершин}
Под ресурсами и вершинами как элементами множеств тут и в дальнейшем будем понимать их уникальные строковые идентификаторы, задаваемый пользователем рантайма.
У каждой вершины $v$, среди прочих, есть следующий набор скрытых свойств, устанавливаемых через функцию декларации:
\begin{itemize}
    \item множества предшествующих и последующих вершин $P_v$ и $F_v$,
    \item множество создаваемых ресурсов $C_v$,
    \item множество читаемых ресурсов $R_v$,
    \item множество изменяемых ресурсов $M_v$,
    \item множество пар переименования ресурсов $E_v$.
\end{itemize}
Именно на основании этих свойств рантайм генерирует рёбра в промежуточном графе по следующим правилам.
Ребро из вершины $v$ в вершину $u$ проводится тогда и только тогда, когда верно хотя бы одно из следующих утверждений:
\begin{itemize}
    \item $v\in P_u$,
    \item $u\in F_v$,
    \item $r \in C_v$ и $r \in M_u$,
    \item $r \in M_v$ и $r \in R_u$,
    \item $r \in R_v$ и $\exists r',\;(r, r') \in E_u$,
    \item $\exists r',\;(r', r) \in E_v$ и $r \in M_u$.
\end{itemize}
Иначе говоря, рантайм гарантирует, что создание ресурса произойдёт раньше, чем все модификации, каждая из модификаций произойдёт раньше, чем каждое чтение, и наконец каждое чтение произойдёт раньше, чем переименование.
При этом само переименование считается моментом создания нового ресурса, соответствующего новому имени.
Если в процессе генерации промежуточного представления из пользовательских вершин получается граф с циклами, либо какой-то ресурс создаётся более чем одной вершиной (считая переименования), рантайм оповещает пользователя об ошибке и предпринимает самостоятельную попытку исправить итоговый граф путём игнорирования некоторых вершин или рёбер.

При генерации промежуточного представления, информация о переименовывании стирается.
Так, одному ресурсу из множества $R$ промежуточного графа может соответствовать несколько различных имён ресурсов, указанных пользователем.

Подобная система упорядочивания гарантирует расширяемость и модульность приложений.Основной компонент приложения может составить \textit{скелетный} кадровый граф, не отображающий ничего, но задающий базовую структуру рендеринга.
\todo{схемка?}
Далее, различные модули приложения могут встраиваться в этот скелет, читая и модифицируя различные ресурсы.

\subsubsection{История ресурсов}
В процессе интеграции одной из ранних версий рантайма кадровых графов, было выяснено, что огромное количество алгоритмов визуализации в целевом приложении использует понятие \textit{истории ресурса}: требуется чтение данных конкретного ресурса в том виде, в котором они находились на конец предыдущего кадра.

Для поддержки таких алгоритмов было введено разделение на \textit{логические} и \textit{физические} ресурсы, где первые представляют собой строковые имена задаваемые пользователем рантайма, а последние "--- регионы памяти GPU, с которыми работают функции запуска вершин.
Для каждого логического ресурса кадрового графа создаётся два физических ресурса, предоставляемых пользователю поочерёдно на чётных и нечётных кадрах.
Это позволяет вершинам, представляющим такие алгоритмы как темпоральное сглаживание \cite{yang2020survey}, одновременно читать историю ресурса и писать сам ресурс.

В дополнение вышеперечисленным множествам запрашиваемых ресурсов каждая вершина содержит множество $H_v$ ресурсов, чья история требуется для выполнения вершины.
Запрос истории с точки зрения упорядочивания вершин приравнивается к чтению, что делает невозможным запрос истории ресурсов, переименуемых в процессе исполнения кадра.

Насколько известно автору, разработанное решение "--- первый рантайм кадровых графов, поддерживающий запросы истории ресурсов, а также способный переиспользовать память ресурсов, чья история запрашивается хотя бы одной вершиной.

\subsubsection{Мультиплексирование}
Следующая проблема, возникшая в процессе интеграции рантайма "--- необходимость запускать некоторые вершины кадрового графа несколько раз в рамках одного кадра.
Возникает такая необходимость в следующих ситуациях:
\begin{itemize}
    \item запуск приложения на устройстве виртуальной реальности, где вид с основной камеры необходимо рендерить для каждого дисплея заново (от 2 до 4 в зависимости от устройства);
    \item поддержка скриншотов в высоком разрешении, где скриншот рендерится по-частям, чтобы не превысить бюджет видеопамяти на потребительских GPU;
    \item поддержка алгоритма SSAA \todo{ссылка};
    \item поддержка локальной многопользовательской игры, где экран делится пополам, и на разных половинах отображается ракурс разных игроков.
\end{itemize}
Для поддержки этих ситуаций в предлагаемом решении введён механизм \textit{мультиплексирования} вершин и ресурсов.

Вводится размерность мультиплексирования, $D$.
Каждая вершина посредством функции декларации указывает свой \textit{режим мультиплексирования}, элемент $\mathbb{Z}_2^D$, являющийся булевой маской выбора измерений.
На режимах мультиплексирования вводится частичный порядок: для $a,b\in\mathbb{Z}_2^D$, $a \preceq b$, если $\forall i,\;a_i \leqslant b_i$.
Каждому ресурсу ставится в соответствие режим мультиплексирования той вершины, которая его создаёт.
Если вершина с режимом $a$ запрашивает ресурс с режимом $b$, то от пользователя требуется, чтобы $b \preceq a$, так как иная ситуация ведёт к неоднозначности выбора физического ресурса.
Также при $u \in P_v$ или $u \in F_v$ требуется, чтобы режимы $u$ и $v$ были сравнимы в частичном порядке $\preceq$.

Перед запуском графа, от пользователя требуется предоставить рантайму $c \in \mathbb{Z}_{>0}^D$.
Во время генерации промежуточного представления, для вершины с режимом $a$ будет создано $\prod_{i=1}^{D} c_i^{a_i}$ вершин  промежуточных промежуточного графа, и аналогично для ресурсов.
Правила проведения рёбер в промежуточном графе обобщаются со случая $c = \left(1, \dots, 1\right)$ естественным образом в силу ограничения из предыдущего абзаца.

Предлагаемая система мультиплексирования покрывает все описанные выше случаи.
Рассмотрим, например, приложение, работающее на VR-устройстве с двумя дисплеями, и использующее алгоритмом сглаживания SSAA x4
Выберем $D = 2$ и $c = (2, 4)$, где первое измерение будет отвечать номеру дисплея, а второе "--- количеству суперпикселей.
Все вершины приложения, визуализирующие вид с основной камеры, должны быть помечены режимом $(1, 1)$.
Вершины же, например, вычисляющие тени, должны быть помечены режимом $(0, 0)$, так как одна и та же карта теней может быть использована для обоих глаз и всех суперпикселей.

\subsubsection{Автоматические разрешения текстур}
Большие неудобства при разработке графических приложений составляет смена разрешения экрана.
Большинство транзиентных ресурсов представляют собой текстуры, разрешение которых кратно разрешению окна приложения, что делает целесообразным разработку централизованного механизма реакции на смену разрешения экрана.

Таким механизмом в предлагаемом решении являются \textit{авторазрешения}.
В вершине, создающей транзиентную текстуру, пользователь рантайма вместо конкретного разрешения может указать строковой идентификатор авторазрешения, числовое значение соответствующее которому сообщается рантайму извне, как правило в коде реакции на смену разрешения окна.
Рантайм, обнаружив на очередном кадре, что одно из авторазрешений поменялось, построит новое расписание ресурсов, тем самым изменяя разрешения физических ресурсов прозрачно для пользователя.

Также система авторазрешений предлагаемого решения поддерживает \textit{динамическую смену разрешений}.
Обнаружив низкую частоту кадров, приложение может уменьшить разрешение, в котором рисуются кадры, чтобы увеличить производительность.
Рантайм кадровых графов в свою очередь позволяет уменьшать разрешения всех текстур с производительностью достаточной чтобы делать это каждый кадр, не освобождая при этом, однако, неиспользуемую память.

\subsubsection{Расстановка барьеров}
Как уже было упомянуто ранее, современные графические API требуют от пользователя в ручную отслеживать использование ресурсов и расставлять в соответствии со спецификацией необходимые ресурсные барьеры.

В разработанном решении для каждого ресурса, встречающегося в множествах $C_v,$ $R_v$, $M_v$, $E_v$ и $H_v$, в вершине хранится пометка о том, как именно в рамках её функции запуска будет использоваться ресурс
Эта информация сохраняется при переходе к промежуточному представлению, и в момент построения расписания ресурсов рантайм в соответствии с этими пометками расставляет так называемые \textit{раздельные барьеры} \cite[раздел~7.5]{VulkanSpec}, позволяющие GPU самостоятельно выбирать подходящий момент времени для выполнения служебной работы по управлению кешами и состояниями ресурсов.

Как будет видно в последующих разделах, необходимость указывать способ использования каждого ресурса в каждой вершине не доставляет больших неудобств пользователям благодаря разработанному публичному API рантайма.

\subsubsection{Однородная поддержка ресурсов CPU}
В начале работы над рантаймом планировалась поддержка лишь GPU ресурсов, однако в процессе интеграции первого прототипа было выяснено, что передача CPU данных, влияющих на запись командных списков, должна тесно взаимодействовать с различными подсистемами рантайма.
В следствии этого было принято решение обобщить механизмы кадровых графов на работу как с данными на GPU, так и с данными на CPU.
Это решение способствует модульности и простоте написания кода новых вершин.
Так, например, матрица преобразования из мирового пространства в экранное пространства, должна отличатся для разных глаз в VR-приложениях.
Чтение этой матрицы во всех вершинах через ресурс кадрового графа позволяет подменить эту матрицу в базовом скелете кадрового графа при адаптации приложения для VR-платформ, не меняя при этом код других вершин.

\subsubsection{Прореживание и валидация кадрового графа}
Как уже было упомянуто выше, в процессе генерации промежуточного представления происходит валидация корректности данных пользователя.

Так, например, возможна ситуация, в которой вершина запрашивает на чтение не произведённый никакой другой вершиной ресурс.
Чтобы предотвратить падения приложения в подобных ситуациях, рантайм находит и исключает из рассмотрения подобные \textit{сломанные} вершины.
Так как сломанная вершина сама могла создавать некоторые ресурсы, в результате этого исключения могут появится новые сломанные вершины, поэтому процедура запускается итеративно, пока находится хотя бы одна сломанная вершина.
Однако встречаются ситуации, в которых вершина способна функционировать даже если один из запрашиваемых ресурсов отсутствует.
Например, некоторые алгоритмы способны работать с глубиной в различных форматах, предоставляя, однако, разный по качеству результат.
Для учёта таких ситуаций запросы ресурсов в вершине могут быть помечены как опциональные, что предотвратит исключение вершины из графа в случае отсутствия соответствующего ресурса.

Возможна и обратная ситуация: запуск вершины может не иметь никаких побочных эффектов кроме создания ресурса, который в итоге не будет использован ни одной другой вершиной.
Чтобы исключить трату вычислительных ресурсов и памяти подобными \textit{висячими} вершинами, рантайм находит и исключает из рассмотрения и их.
Однако в процессе интеграции рантайма кадровых графов в движок не редко возникали ситуации, в которых побочные эффекты запуска вершины производились незаметно для кадрового графа, в обход системы ресурсов.
Чтобы подобные вершины не выкидывались рантаймом, функция декларации может пометить вершину флагом внешних побочных эффектов.

\subsubsection{Внешние ресурсы}
Некоторые особые виды ресурсов не могут управляться рантаймом кадровых графов, так как само графическое API не предоставляет прямой доступ к ним.
Например, изображения \textit{свопчейна} создаются операционной системой, и хранятся в памяти управляемой ей.
Более того, для интеграции некоторых часто используемых ресурсов движка в кадровый граф требовалось слишком больше количество изменений в коде.
Для постепенной интеграции этих ресурсов, а также поддержки внешних по отношению ко всему приложению ресурсов, в рантайм было добавлено понятие \textit{внешних ресурсов}.
Внешние ресурсы работают аналогично остальным за исключением управления их памятью.
При создании внешнего ресурса, вместо предоставления данных, необходимых для создания подобного ресурса в рамках рантайма, от пользователя требуется предоставить функцию, отображающую текущий \textit{индекс мультиплексирования} в уже существующий физический ресурс.
Здесь, индекс мультиплексирования "--- вектор, описывающий номер запуска вершины в рамках мультиплексирования.
Рантайм в свою очередь запускает эту функцию перед каждым запуском соответствующий вершины, и предоставляет всем последующим вершинам полученный физический ресурс в качестве запрошенного логического.

\subsubsection{Управление глобальным состоянием}
Как правило, перед запуском работы на GPU посредством вызова отрисовки или запуска вычислительного шейдера, необходимо выставить некоторый набор глобальных состояний GPU посредством специальных команд.
Для нескольких подряд идущих вершин, эти команды могут быть абсолютно одинаковыми.
Так, например, при отрисовки G-буфера, набор целевых изображений не будет отличатся между вершинами.
Переключение этих состояний "--- не самая долгая операция, однако переключая их зазря перед каждым вызовом отрисовки всё равно можно значительно замедлить работу приложения.

Чтобы избежать этой ситуации, выставление состояний GPU было интегрировано в рантайм кадровых графов.
Пользователь указывает необходимое на момент запуска состояние в функции декларации, а рантайм находит оптимальную последовательность смены состояний в процессе исполнения графа, минимизируя тем самым накладные расходы.

\subsection{Пользовательское API рантайма}
В рамках данной работы также было разработано эргономичное для разработчиков API для работы с рантаймом кадровых графов. Рассмотрим простейший пример его использования, изображённый на рисунке \ref{fig:exampleNode1}.
\begin{figure*}
\begin{minted}[linenos, escapeinside=!!]{c++}
dabfg::NodeHandle makeExampleNode1()
{
  return dabfg::register_node("example_node_1", DABFG_PP_NODE_SRC, !\mintlbl{registerNode}!
    [](dabfg::Registry registry) !\mintlbl{nodeDeclare}!
    {
      auto cpuDataHndl = registry !\mintlbl{blobHandle}!
        .readBlob<DataType>("cpu_data")
        .handle();

      return
        [cpuDataHndl]() !\mintlbl{nodeExecute}!
        {
          const DataType &data = *cpuDataHndl;
          !\dots!
        };
    });
}
\end{minted}
\caption{Листинг элементарного примера использования разработанного API.}
\label{fig:exampleNode1}
\end{figure*}
Вершины создаются при помощи функции \inlcpp{dabfg::register_node} (строка \ref{registerNode}), возвращающей объект \inlcpp{dabfg::NodeHandle}.
Созданная вершина автоматически попадает в глобальный кадровый граф и автоматически удаляется, как только удалён соответствующий объект \inlcpp{dabfg::NodeHandle}.
На вход функция регистрация вершин принимает название, специальный макрос\footnote{Использование макроса необходимо для получения названия файла и номера текущей строки, используемых для диагностики кадровых графов.} и лямбда-функцию декларации (строка \ref{nodeDeclare}), от которой в свою очередь требуется вернуть функцию запуска вершины (строка \ref{nodeExecute}).
Подобный дизайн вложенных лямбд позволяет захватывать \textit{хэндлы} ресурсов, получаемые в функции декларации, и получать из них данные в функции запуска.
Так, например, в строке \ref{blobHandle} у объекта \inlcpp{dabfg::Registry}, отвечающего за декларативное описание скрытых параметров вершины, запрашивается на чтение CPU-ресурс \inlcpp{"cpu_data"} с типом \inlcpp{DataType}.
Далее, хэндл этого ресурса захватывается в лямбда-функцию запуска, и разыменовывается для доступа к соответствующим данным, созданным в иной вершине.
Стоит отметить, что доступ к данным предоставляется по константной ссылке, только на чтение, так как для изначального запроса был использован шаблон функции \inlcpp{readBlob}.
В случае использования парного шаблона \inlcpp{modifyBlob}, обозначающего модификацию ресурса и соответственно иначе влияющего на упорядочивание вершин, тип возвращаемого хэндла меняется и предоставляет доступ и на запись.
Наконец, режимом мультиплексирования по-умолчанию для вершин является полное мультиплексирование, поэтому функция запуска будет запущена не единожды, и более того, на каждом запуске разыменовывание \inlcpp{cpuDataHandle} будет возвращать ссылку на разные объекты в памяти, соответствующие разным индексам мультиплексирования.

Рассмотрим более сложный пример, использующий всю силу разработанного API.
На рисунке \ref{fig:exampleNode2} приведён листинг вершины, рисующей некоторый набор объектов, получаемый через CPU-ресурс \inlcpp{"objects"} при помощи предположительного шейдера \inlcpp{"shaderForObjects"}\footnote{Функция \inlcpp{createShader} использована исключительно для экспозиции и не является частью разработанного API.}.
\begin{figure*}
\begin{minted}[linenos, escapeinside=!!]{c++}
dabfg::NodeHandle makeExampleNode2(bool useHistory)
{
  return dabfg::register_node("example_node_2", DABFG_PP_NODE_SRC,
    [useHistory](dabfg::Registry registry)
    {
      registry.orderMeAfter("some_other_node"); !\mintlbl{legacyOrdering}!

      auto colorRequest = registry.renameTexture("color",
        "color_after_example", dabfg::History::ClearOnFirstFrame); !\mintlbl{historyClear}!
      auto depthRequest = registry.modifyTexture("gbuf_depth");

      registry.requestRenderPass() !\mintlbl{renderPass}!
        .color({std::move(colorRequest), "additional_color"})
        .depth(std::move(explicitDepthRequest));

      registry.readTexture("some_optional_input_texture") !\mintlbl{optionalInput}!
        .optional()
        .atStage(dabfg::Stage::PS)
        .bindToShaderVar("some_optional_shader_input");

      if (useHistory) !\mintlbl{historyRequest}!
        registry.readTextureHistory("color_after_example")
          .atStage(dabfg::Stage::PS)
          .bindToShaderVar("previous_frame_color");

      auto objectsHndl = registry
        .readBlob<ObjectContainer>("objects")
        .handle();

      return
        [objectsHndl, shader = createShader("shaderForObjects")]()
        {
          shader.render(*objectsHndl);
        };
    });
}
\end{minted}
\caption{Листинг усложнённого примера использования разработанного API.}
\label{fig:exampleNode2}
\end{figure*}
Однако известно, что перед тем как запускать отрисовку шейдером, необходимо выставить различные состояния драйвера.
В данном примере все необходимые состояния выставляются полностью через разработаннео API.
В строке \ref{renderPass} запрашивается \textit{виртуальный проход отрисовки}, в рамках которого целями для отрисовки цветов выбраны логические ресурсы \inlcpp{"color"} и \inlcpp{"additional_color"}, а буфером глубины ресурс \inlcpp{"gbuf_depth"}.
Стоит заметить отличие в способах указания этих ресурсов в качестве целей отрисовки.
Для глубины использован стандартный полный синтаксис: явно запрошен соответствующий ресурс глубины на модификацию, и затем объект запроса указан в качестве глубины прохода отрисовки.
Для \inlcpp{"additional_color"} же использован сокращённый синтаксис: указание названия ресурса на прямую в функциях \inlcpp{color} и \inlcpp{depth} автоматически запрашивает соответствующий ресурс на модификацию.
Для \inlcpp{"color"} же использовано переименование, влияющие описанным в предыдущих разделах образом на порядок исполнения вершин и также считающееся модификацией с точки зрения использования ресурсов в рамках запуска вершины.
Более того, в строке \ref{historyClear} указано, что у переименованного ресурса должна быть включена история, а также указано, что на первом кадре после компиляции графа в качестве истории рантайм должен предоставить очищенную текстуру.
В строке \ref{historyRequest} же в зависимости от настройки, приходящей извне, запрашивается история ресурса, созданного в результате переименования, \inlcpp{"color_after_example"}, и сразу же привязывается в качестве значения входного параметра \inlcpp{"previous_frame_additional_color"} пиксельного шейдера.
Заметим, что указание набора шейдеров в которых будет использоваться текстура в качестве семплируемого параметра обязательно для корректной расстановки барьеров.
В случае использования ресурса как цели прохода отрисовки же ничего указывать не требуется, так как подобное использование возможно лишь в пиксельном шейдере.
Отметим также, что в случае использования GPU ресурса напрямую в функции посредством захвата его хэндла, абсолютно необходимо указать способ его дальнейшего использования при помощи функций \inlcpp{atStage} и \inlcpp{useAs}.
В строке \ref{optionalInput} же запрашивается \inlcpp{опциональный} ресурс, в случае отсутствия которого вершина всё равно будет запущена, а в соответствующий входной параметр шейдера будет помещена пометка об отсутствии текстуры.
Наконец, в строке \ref{legacyOrdering} текущая вершина явно упорядочивается с другой вершиной.
Однако механизм прямого упорядочивания вершин менее устойчив к изменению и модуляризации кода, поэтому предполагается к использованию лишь в крайних случаях и в качестве временного решения в процессе миграции кодовой базы на кадровый граф.

В предлагаемом API есть ряд инвариантов корректности.
Например, необходимо, чтобы пользователь не мог получить хэндл GPU-ресурса не указав как конкретно он собирается его использовать; недопустимо, чтобы в качестве цветовой цели прохода отрисовки был указан запрос на чтение ресурса; а также перед вызовом функции \inlcpp{bindToShaderVar} необходимо указывать вид шейдера, в котором ресурс будет использоваться.
При помощи шаблонов языка C++ в разработанном API были достигнуты гарантии соблюдения этих многих из этих инвариантов на этапе компиляции.
Фактически каждая функция, вызываемая в рамках функции декларации, возвращает объект нового типа.
Так, у типа представляющего запрос ресурса до вызова функции \inlcpp{atStage} полностью отсутствует метод \inlcpp{bindToShaderVar}, а вызов \inlcpp{atStage} возвращает объект нового типа, у которого уже есть этот метод.
Аналогично различными типами обладают объекты возвращаемые из функций \inlcpp{readTexture}, \inlcpp{modifyTexture}, \inlcpp{readBlob} и так далее, обладающие лишь необходимым функционалом.
Подобный дизайн API позволяет избежать многих элементарных ошибок в рамках разработки приложения, основанного на кадровом графе, экономя время и силы прикладных разработчиков.

\subsection{Построение расписания ресурсов}
Последний, и наиболее важный в данной работе этап компиляции кадрового графа -- построение расписания ресурсов.
На вход этому этапу поступает промежуточное представление $(V, E, R, U, H)$, а в результате необходимо построить отображение $\Omega : i, j, k \mapsto \rho$, где $i$ "--- логический ресурс, $j$ "--- номер кадра по модулю 2, $k$ "--- индекс мультиплексирования, а $\rho$ "--- физический ресурс.
Это отображение и будет использоваться перед запуском вершин рантаймом чтобы предоставить пользователю физические ресурсы для чтения и записи.
Более того, именно на данном этапе рантайм вычисляет \textit{события}, происходящие с ресурсами: активация, деактивация и барьеры.
Во время исполнения кадрового графа на основе этих событий в командные списки записываются соответствующие команды между запуском вершин.
Этот процесс не представляет научного интереса, поэтому оставшаяся часть раздела посвящена получению $\Omega$.

Для дальнейшего построения алгоритма потребуется ввести понятие циклического времени.
Так, в дальнейшем, термин \textit{время} будет подразумевать элементы циклической группы $Z_T$, где $T = 2\left|V\right|$.
Для $a, b \in Z_T$, обозначим за $[a, b)$ множество $\left\{a, a+1, \dots, b\right\}$ если $a < b$, и множество $\left\{b, b + 1, \dots, T - 1\right\} \cup \left\{0,1, \dots, a\right\}$ иначе.
Предположим, что вершины промежуточного графа $V$ уже прономерованы в порядке выбранной топологической сортировки.
Определим времена жизни физических ресурсов, порождённых ресурсом $i$, $[l^e_i, r^e_i)$ и $[l^o_i, r^o_i)$:
\begin{align*}
l_i &= 1 + \min_{i \in U(v_j)} j\\
r_i &= 1 + \max_{i \in U(v_j)} j\\
r'_i &= 1 + \max_{i \in H(v_j)} j\\
\\
l^e_i &= l_i,\\
l^o_i &= \left|V\right| + l_i,\\
r^e_i &=
    \begin{cases}
        \left|V\right| + r'_i, & \text{$r'_i$ определено} \\
        r_i, & \text{иначе}
    \end{cases} \\
r^o_i &=
\begin{cases}
    r'_i, & \text{$r'_i$ определено} \\
    \left|V\right| + r_i, & \text{иначе}
\end{cases}
\end{align*}
где $r'_i$ не определено тогда и только тогда, когда история ресурса $i$ ни разу не была использована; см. рис. \ref{fig:twoFrameLifetime}.
\begin{figure*}[ht]
\centering
\begin{tikzpicture}[scale=1.125, every node/.style={scale=0.8}]
    \linespread{1}
%
    \foreach \x in {0,...,14} {
        \draw [help lines, dashed] (\x-.5,1) -- ++(0,-4.5);
    }
    \draw (6.5,1.5) -- ++(0,-5);
    \draw (3, 1.5) node {Чётный кадр};
    \draw (10, 1.5) node {Нечётный кадр};
%
    \begin{scope}
        \node[align=center] (A) at (0, 0)   {A\\$\alpha$};
        \node[align=center] (B) at (1, .5)  {B\\$\alpha$};
        \node[align=center] (C) at (2, -.5) {C\\$\alpha$};
        \node[align=center] (D) at (3, 0)   {D\\$\alpha,\beta$};
        \node[align=center] (E) at (4, 1)   {E\\$\gamma$};
        \node[align=center] (F) at (5, 0)   {F\\$\beta,\gamma$};
        \node[align=center] (G) at (6, 0)   {G\\$\beta,\beta_h$};
%
        \graph {
            (A) -> {(B), (C)} -> (D) -> (F) -> (G);
            (E) -> (F);
        };
%
        \node[align=center] (A') at (7, 0)   {A\\$\alpha$};
        \node[align=center] (B') at (8, .5)  {B\\$\alpha$};
        \node[align=center] (C') at (9, -.5) {C\\$\alpha$};
        \node[align=center] (D') at (10, 0)  {D\\$\alpha,\beta$};
        \node[align=center] (E') at (11, 1)  {E\\$\gamma$};
        \node[align=center] (F') at (12, 0)  {F\\$\beta,\gamma$};
        \node[align=center] (G') at (13, 0)  {G\\$\beta,\beta_h$};
%
        \graph {
            (A') -> {(B'), (C')} -> (D') -> (F') -> (G');
            (E') -> (F');
        };
    \end{scope}
%
    \begin{scope}[shift={(-.5, -1.5)}]
        \draw [ultra thick] (-.25, .5) -- ++(14.5, 0);
        \draw [thick, Bracket-Parenthesis] (0, 0) -- node[above] {$\alpha^e$} ++(4, 0);
        \draw [thick, Bracket-Parenthesis] (3, -.5) -- node[above] {$\beta^e$} ++(11, 0);
        \draw [thick, Bracket-Parenthesis] (4, -1) -- node[above] {$\gamma^e$} ++(2, 0);
%
        \draw [thick, Bracket-Parenthesis] (7, 0) -- node[above] {$\alpha^o$} ++(4, 0);
        \draw [thick, Bracket-Parenthesis] (11, -1) -- node[above] {$\gamma^o$} ++(2, 0);
        \draw [thick, Bracket-] (10, -1.5) -- node[above] {$\beta^o$} ++(4.25, 0);
        \draw [thick, -Parenthesis] (-.25, -1.5) -- node[above] {$\beta^o$} ++(7, 0);
    \end{scope}
\end{tikzpicture}
\caption{Визуализация отрезков времени жизни физических ресурсов.
В верхней половине изображён промежуточный граф с выбранным порядком исполнения.
Вершины, обозначенные заглавными латинскими буквами, исполняются слева направо.
Под вершинами перечислены списки запрашиваемых ими ресурсов, обозначенных греческими буквами, а также через нижний индекс $h$ обозначены запрашиваемые истории ресурсов.
В нижней половине изображены отрезки времён жизни физических ресурсов для чётных и нечётных кадров соответственно.}
\label{fig:twoFrameLifetime}
\end{figure*}
Далее, для полученных интервалов времени жизни физических ресурсов и размеров соответствующих логических ресурсов, необходимо решить задачу дискретной оптимизации, называемую в рамках данной работы циклической динамической аллокацией ресурсов (от англ. cyclic dynamic storage allocation, сокращённо CDSA), и формулируемую следующим образом.

Пусть $l_i, r_i \in \mathbb{Z}_T$, $s_i \in \mathbb{Z}_{>0}$, $i=\overline{0,n}$.
Допустимой функцией аллокации называют функцию $\alpha : \overline{0,n} \to \mathbb{Z}_{\geqslant 0}$ такую, что для любых $i \neq j$, либо $\left[l_i, r_i\right) \cap \left[l_j, r_j\right) = \emptyset$ в смысле циклического времени, либо $\left[\alpha(i), \alpha(i) + s_i\right) \cap \left[\alpha(j), \alpha(j) + s_j\right) = \emptyset$.
Для функции аллокации $\alpha$, определена величина $makespan = \max_i \alpha(i) + s_i$.
Задача "--- найти допустимую функцию аллокации $\alpha_{\min}$, минимизирующую величину $makespan$.

Эта задача "--- обобщение хорошо известной в литературе задачи динамической аллокации памяти (от англ. dynamic storage allocation, сокращённо DSA), необходимое для учёта запросов к истории ресурсов.
Рассмотрим частный случай этой задачи, в котором все веса ресурсов единичны, то есть $\forall i,\;s_i = 1$.
Ясно, что решение этого частного случая эквивалентно раскраске графа пересечений множеств $\left[l_i, r_i\right)$, которые в свою очередь эквивалентны дугам окружности длины $T$.
Известно, что задача раскраски графа пересечений дуг окружности $\NP$-полна \cite{doi:10.1137/0601025}.
Следовательно, и поставленная задача CDSA $\NP$-полна, а значит для её решения необходимы схемы приближения.

В рамках данной работы предлагается следующий алгоритм приближённого решения задачи CDSA, см. алгоритм \ref{fig:ouralgo}.
\begin{algorithm}
\begin{algorithmic}[1]
\State $X \gets$ входное множество ресурсов
\State $Y \gets \emptyset$ "--- мн-во пар живых ресурсов и пометок $until$ соответствующих блоков
\State $A \gets \emptyset$ "--- мн-во доступных блоков $(offset, size, until)$
\State $H \gets 0$ "--- текущий размер кучи
\State $t_0 \gets$ момент времени с наименьшим $L(t)$
\State $t \gets t_0$
\For{ресурс $i$ жив в $t$}
    \State $\alpha(i) \gets H$
    \State $H \gets H + s_i$
    \State Удалить $i$ из $X$
    \State Добавить $(i, l_i)$ в $Y$
\EndFor
\Repeat
    \For{$\left(j, until\right) \in Y$}
        \If{$j$ не жив в $t$}
            \State Удалить $j$ из $Y$
            \State Добавить $(\alpha(j), s_j, until)$ в $A$
            \State Дефрагментировать $A$
        \EndIf
    \EndFor

    \State $i \gets$ элемент $X$ с наименьшим $l_i - t \mod T$
    \State Удалить $i$ из $X$

    \If{выбор эл-та $A$ провалится на следующем шаге}
        \State Добавить блок $(H, s_i, \infty)$ в $A$
        \State Дефрагментировать $A$
        \State $H \gets H + s_i$
    \EndIf

    \State $a \gets$ блок с наименьшим $size \geqslant s_i$ в $A$ такой, что $[l_i, r_i) \cap [until, t_0) = \emptyset$ или $until = \infty$
    \State Удалить $a$ из $A$

    \State $\alpha(i) \gets a.offset$
    \If{$a.size > s_i$}
        \State Добавить $(a.offset + s_i, a.size - s_i, a.until)$ в $A$
        \State Дефрагментировать $A$
    \EndIf

    \State Добавить $\left(i, a.until\right)$ в $Y$
    \State $t \gets l_i$
\Until{в $X$ не останется элементов}
\end{algorithmic}
\caption{Предлагаемый жадный алгоритм решения CDSA}
\label{fig:ouralgo}
\end{algorithm}
Вход алгоритма~-- множество ресурсов, троек $(l_i, r_i, s_i)$, выход "--- функция $\alpha$, хранимая в виде массива, и обозначающая сдвиг каждого ресурса относительно начала \textit{кучи}, последовательности страниц видеопамяти.
В рамках алгоритма \textit{живым} в момент времени $t$ ресурсом называют такой ресурс $i$, что $t \in \left[l_i, r_i\right)$.
В процессе работы алгоритма поддерживаются 2 структуры: множество живых в текущий момент времени $t$ ресурсов $Y$ с пометками $until$ соответствующих блоков и множество уже однажды аллоцированных но доступных для переиспользования блоков памяти $A$, где блок "--- тройка $(offset, size, until)$, позиции в рамках кучи, размер блока и время, до которого этот блок доступен, соответственно.
В программной реализации для хранения этих структур используются красночёрные деревья поиска.
В некоторые моменты алгоритма происходит \textit{дефрагментация} множества $A$: блоки, имеющие одинаковую пометку $until$ и расположенные в памяти подряд, объединяются в один большой блок.
Далее, также в рамках алгоритма, а также дальнейшего анализа, используется величина $L(t) = \sum_{i: t \in [l_i, r_i)} s_i$, называемая \textit{нагрузкой} в момент времени $t$.
В начале алгоритма, в строке 5, выбирается опорная точка $t_0$ "--- начало движения сканирующей прямой.
В дальнейшем текущее положение сканирующей прямой хранится в переменной $t$, а переменная $H$ используется для отслеживания текущего размера кучи.
В строках 7--12 в память подряд укладываются ресурсы, живые в опорной точке $t_0$, а также добавляются в множество $Y$ с началами их времён жизни в качестве пометок.
Далее, алгоритм повторяет цикл на строках 13--37 пока не кончатся элементы в $X$, выбирая каждый раз ресурс с началом времени жизни ближайшим к текущему положению сканирующей прямой $t$, что в программной реализации достигается путём сортировки массива $X$ относительно $t_0$.
В рамках этого цикла в первую очередь, в строках 14--20, <<освобождаются>> ресурсы, чьё время жизни уже закончилось, возвращая для них соответствующие блоки памяти в $A$.
Следующим шагом алгоритм выбирает новый ресурс в строке $21$, помечает его живым, и пытается переиспользовать уже имеющийся в $A$ блок памяти.
Впрочем подходящего блока может не найтись.
В таком случае в строках 23--27 создаётся новый блок подходящего размера на вершине кучи памяти, с пометкой $until = \infty$.
После этого в строке 28 находится блок согласно стратегии <<best-fit>>, то есть блок минимального размера среди тех, в которых помещается блок, и при этом время жизни ресурса не пересекает границу $until$.
Ровно для последнего условия в рамках алгоритма отслеживаются эти пометки, что гарантирует отсутствие пересечений с выделенными в строках $7--12$ ресурсами.
Позиция в памяти выбранного блока берётся в качестве значением функции $\alpha$ для текущего ресурса.
Однако выбранный блок мог быть много больше по размеру чем ресурс, поэтому оставшееся в нём свободное место отрезается и добавляется обратно в структуру $A$.
Наконец, позиция сканирующей прямой обновляется до начала текущего ресурса, $l_i$, и алгоритм переходит к следующей итерации.

Получив функцию аллокации и размер итоговой кучи, несложно построить итоговую для данного этапа компиляции кадрового графа функции $\Omega$.
При помощи графического API создаётся куча видеопамяти соответствующего размера, а затем для каждого номера физического ресурса $p$ на позиции $\alpha(p)$ в куче создаётся соответствующий ресурс.
Далее, для логического ресурса $i$, номера кадра $j$ по модулю 2 и индекса мультиплексирования $k$, найдём соответствующий номер физического ресурса $p$, и определим $\Omega(i, j, k)$ как созданный ресурс графического API, соответствующий индексу $p$.

В заключение данного раздела отметим, что на практике некоторые платформы имеют несколько различных видов видеопамяти.
Программная реализация предложенного метода поддерживает эту особенность, группируя физические ресурсы по целевым типам видеопамяти, решая для каждого типа памяти задачу CDSA независимо и соответственно создавая несколько независимых куч.
