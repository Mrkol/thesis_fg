\section{Введение}

\subsection{Управление ресурсами в графических приложениях реального времени}
В процессе вычисления картинки одного кадра любое нетривиальное приложение использует \textit{транзиентные ресурсы} -- промежуточные хранилища данных, содержимое которых не требуется после окончания вычисления кадра, либо, требуется лишь в процессе вычисления следующего кадра. Основная отличительная черта рассматриваемого подхода заключается в известности всей информации о транзиентных ресурсах заранее, что позволяет управлять ими более эффективно. Более того, рассматриваемый подход позволяет добиться в определённом смысле оптимальной работы с такими ресурсами, как будет видно дальше. Однако обязательным пререквизитом для эффективной аллокации ресурсов является использование современного графического API, предоставляющего возможность ручного управления видеопамятью. До появления подобных API большая часть приложений использовало один из следующих наивных подходов к управлению ресурсами.

Самый простым подходом является выделение и освобождение транзиентных ресурсов по ходу их нужды при помощи соответствующих вызовов графического API. Этот подход фактически идентичен выделению памяти в различных языках программирования: драйвер операционной системы содержит аллокатор, на который пользователь перекладывает обязанность управления памятью и другими ресурсами GPU, аналогично аллокациям на куче в языке C. Системный аллокатор переиспользует освободившуюся память, тем самым достигая низкого её потребления. Однако такой подход не масштабируется на более сложные приложения. Во-первых известны нижние оценки на качество работы аллокаторов [ССЫЛК НА ОЦЕНКУ ОНЛАЙН DSA], на практике выражающиеся как фрагментация кучи. Во-вторых, как правило этот подход подразумевает использование подсчёта количества ссылок на выделенные ресурсы, что приводит к значительным накладным расходам по всему приложению.

Альтернативным подходом служит отказ от переиспользования памяти. Все транзиентные ресурсы создаются заранее и не удаляются в ходе работы приложения. Очевидно что с повышением сложности приложения такой подход перестаёт быть применимым, что нередко влечёт к попыткам в ручную переиспользовать некоторые выделенные объекты. Это в свою очередь приводит к чрезвычайно сложному для понимания коду, усложняя работу над самим приложением.

Наконец, наиболее практичным из альтернативных подходом является пулинг ресурсов. Вся программа работает с объектом называемым пулом, отвечающим за выделение и освобождение ресурсов. Пул использует аллокатор драйвера для выделения новых ресурсов, но вместо освобождения ресурсов в драйвер хранит список неиспользуемых ресурсов конкретного типа (в понятие тип как правило входит разрешение для текстур и размер для буфферов соответственно, а также все флаги свойств ресурса). Последующие запросы на выделение ресурсов обслуживаются в первую очередь из списка неиспользуемых, и только исчерпав его выделяются новые посредством драйвера операционной системы. Данный подход был оптимален до появления современных низкоуровневых графических API, однако в настоящее время хорошо заметен его главный недостаток: память не переиспользуется между ресурсами разных типов.

\subsection{Кадровый граф}
Написать про:
* память
* архитектурную крутизну ресурсных зависимостей
* барьеры
* рендерпассы и TBDR
* автоматический подбор хорошего для платформы порядка исполнения
* многопоточную запись комманд
* автоматический асинк
* мультиплексирование и прочие "циклы"
* историю ресурсов
