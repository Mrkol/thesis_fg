\section{Введение}
Около 10 лет назад история развития компьютерной графики реального времени потерпела кардинальный поворот с выходом графических API нового поколения, DirectX12, Vulkan и Metal, в 2014, 2016 и 2014 годах соответственно.
Их предшественники, OpenGL и DirectX ранних версий, основывались на идее так называемого <<толстого>> драйвера.
Дизайн этих API старался максимально скрыть принципы работы видеокарт, предоставляя пользователям простой, но достаточно ограниченный инструмент для разработки графических приложений реального времени.
По мере развития индустрии компьютерной графики, разработчики приложений всё чаще сталкивались с ограничениями старых API, а простота дизайна всё больше жертвовалась в пользу поддержки новых возможностей графических ускорителей.
Обусловлено это возрастающими требованиями к приложениям со стороны клиентов.

В индустриях игр, кино, виртуальных тренировочных симуляторов, а также промышленной визуализации, очень важно качество и реализм картинки.
За годы академических исследований компьютерной графики было предложено большое количество техник и алгоритмов визуализации самых различных сцен, а развитие потребительской и промышленной техники привело к распространению широкого спектра устройств для запуска приложений.
Так, не редка ситуация в которой одно и то же приложение должно масштабироваться от профессиональных персональных компьютеров с мощнейшими процессорами, видеокартами и мониторами в разрешении 8K, и до потребительских HMD-устройств, и даже телефонов и портативных консолей.
От разработчиков приложений ожидается масштабируемость на этот широкий спектр устройств, с учётом всей их специфики, при этом не отказываясь от использования современных алгоритмов и техник визуализации сцен.

Главной целью дизайна графических API нового поколения было позволить разработчикам добиться этой цели, в следствии чего произошёл отказ от <<толстых>> драйверов в пользу раскрытия всё большего числа деталей работы графических ускорителей.
В следующем подразделе более детально освещены различные аспекты этого перехода, а также проблемы, возникающие при разработке приложений с использованием новых графических API.

\subsection{Аспекты разработки графических приложений реального времени в старых и новых API}
\subsubsection{Управление памятью транзиентных ресурсов GPU}
В процессе вычисления картинки одного кадра любое нетривиальное приложение использует \textit{транзиентные ресурсы} -- промежуточные хранилища данных, содержимое которых не требуется после окончания вычисления кадра, либо, требуется лишь в процессе вычисления следующего кадра.
Как правило, подобные ресурсы являются картинками с разрешением кратным разрешению монитора пользователя.
Из этого следует, что при переходе от 1080p мониторов к 4K мониторам потребление памяти транзиентными ресурсами возрастает в 4 раза, что обуславливает нужду в эффективном её переиспользовании.
Старые графические API полностью скрывали управление памятью GPU от пользователя, предоставляя лишь функции создания и удаления конкретных ресурсов.
За годы существования этой абстракции образовалось 3 основных подхода к эффективному управлению памятью транзиентных ресурсов.

Самый простым подходом является выделение и освобождение транзиентных ресурсов по ходу их нужды при помощи соответствующих вызовов графического API.
Этот подход фактически идентичен выделению памяти в различных языках программирования: драйвер операционной системы содержит аллокатор, на который пользователь перекладывает обязанность управления памятью и другими ресурсами GPU, аналогично аллокациям на куче в языке C.
Системный аллокатор переиспользует освободившуюся память, тем самым достигая низкого её потребления.
Однако, такой подход не масштабируется на более сложные приложения. Во-первых известны нижние оценки на качество работы аллокаторов реального времени \todo{ссылка на оценку онлайн DSA}, на практике выражающиеся как фрагментация кучи.
Во-вторых, как правило и создание и освобождение ресурсов является весьма дорогой операцией в следствии деталей реализации драйверов.
\todo{мб объяснить почему?}

Альтернативным подходом служит отказ от переиспользования памяти. Все транзиентные ресурсы создаются заранее и не удаляются в ходе работы приложения. Очевидно, что с повышением сложности приложения такой подход перестаёт быть применимым, что иногда влечёт к попыткам в ручную переиспользовать некоторые выделенные объекты. Это, в свою очередь, приводит к чрезвычайно сложному для понимания коду, усложняя работу над самим приложением.

Наконец, наиболее практичным подходом является пуллинг ресурсов.
Вся программа работает с объектом называемым пулом, отвечающим за выделение и освобождение ресурсов.
Пул использует аллокатор драйвера для выделения новых ресурсов, но вместо освобождения ресурсов в драйвер хранит список неиспользуемых ресурсов конкретного типа (в понятие тип как правило входит разрешение для текстур и размер для буфферов соответственно, а также все флаги свойств ресурса).
Последующие запросы на выделение ресурсов обслуживаются в первую очередь из списка неиспользуемых, и только исчерпав его выделяются новые посредством драйвера операционной системы.
Данный подход был оптимален до появления современных низкоуровневых графических API, однако в настоящее время хорошо заметен его главный недостаток: память не переиспользуется между ресурсами разных типов.

В современных же графических API предоставляется прямой доступ к памяти GPU.
Приложение может выделять \textit{кучи} в видеопамяти, последовательности страниц виртуальной видеопамяти, и затем создавать ресурсы на конкретных адресах на куче.
Стоит отметить, что пересечение используемых разными ресурсами регионов кучи не запрещается, хоть поведение при одновременном использование таких ресурсов не определено.
Фактически, это нововведение перекладывает ответственность по написанию аллокатора ресурсов с разработчиков драйвера на разработчиков приложения.
С одной стороны, это сильно усложняет разработку простых приложений, в следствии чего компания AMD открыла исходный код аллокатора из своих драйверов \todo{ссылка}.
С другой стороны, это даёт возможность разработчикам более эффективно распоряжаться видеопамятью в различных частях приложения, в частности, позволяя построить в некотором смысле оптимальное расписание аллокации транзиентных ресурсов.

\subsubsection{Отправка команд GPU}
\todo{Написать про async compute и проблемы с многопоточностью}

\subsubsection{Управление кешами GPU}
\todo{Написать про барьеры}

\subsection{Кадровый граф}
\todo{Написать про:}
\begin{itemize}
\item \todo{память}
\item \todo{архитектурную крутизну ресурсных зависимостей}
\item \todo{барьеры}
\item \todo{рендерпассы и TBDR}
\item \todo{автоматический подбор хорошего для платформы порядка исполнения}
\item \todo{многопоточную запись команд}
\item \todo{автоматический асинк}
\item \todo{мультиплексирование и прочие "циклы"}
\item \todo{историю ресурсов}
\end{itemize}
